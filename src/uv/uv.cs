
//-------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the following tool:
//        https://github.com/bottlenoselabs/c2cs (v1.7.13.0)
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ReSharper disable All
//-------------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;


#nullable enable
#pragma warning disable 1591

public static unsafe partial class uv
{
    private const string LibraryName = "uv";

    // Function @ uv.h:265:24
    [DllImport(LibraryName)]
    public static extern uint uv_version();

    // Function @ uv.h:266:23
    [DllImport(LibraryName)]
    public static extern CString uv_version_string();

    // Function @ uv.h:273:16
    [DllImport(LibraryName)]
    public static extern void uv_library_shutdown();

    // Function @ uv.h:275:15
    [DllImport(LibraryName)]
    public static extern int uv_replace_allocator(uv_malloc_func malloc_func, uv_realloc_func realloc_func, uv_calloc_func calloc_func, uv_free_func free_func);

    // Function @ uv.h:280:22
    [DllImport(LibraryName)]
    public static extern uv_loop_t* uv_default_loop();

    // Function @ uv.h:281:15
    [DllImport(LibraryName)]
    public static extern int uv_loop_init(uv_loop_t* loop);

    // Function @ uv.h:282:15
    [DllImport(LibraryName)]
    public static extern int uv_loop_close(uv_loop_t* loop);

    // Function @ uv.h:288:22
    [DllImport(LibraryName)]
    public static extern uv_loop_t* uv_loop_new();

    // Function @ uv.h:294:16
    [DllImport(LibraryName)]
    public static extern void uv_loop_delete(uv_loop_t* param);

    // Function @ uv.h:295:18
    [DllImport(LibraryName)]
    public static extern ulong uv_loop_size();

    // Function @ uv.h:296:15
    [DllImport(LibraryName)]
    public static extern int uv_loop_alive(uv_loop_t* loop);

    // Function @ uv.h:297:15
    [DllImport(LibraryName)]
    public static extern int uv_loop_configure(uv_loop_t* loop, uv_loop_option option);

    // Function @ uv.h:298:15
    [DllImport(LibraryName)]
    public static extern int uv_loop_fork(uv_loop_t* loop);

    // Function @ uv.h:300:15
    [DllImport(LibraryName)]
    public static extern int uv_run(uv_loop_t* param, uv_run_mode mode);

    // Function @ uv.h:301:16
    [DllImport(LibraryName)]
    public static extern void uv_stop(uv_loop_t* param);

    // Function @ uv.h:303:16
    [DllImport(LibraryName)]
    public static extern void uv_ref(uv_handle_t* param);

    // Function @ uv.h:304:16
    [DllImport(LibraryName)]
    public static extern void uv_unref(uv_handle_t* param);

    // Function @ uv.h:305:15
    [DllImport(LibraryName)]
    public static extern int uv_has_ref(uv_handle_t* param);

    // Function @ uv.h:307:16
    [DllImport(LibraryName)]
    public static extern void uv_update_time(uv_loop_t* param);

    // Function @ uv.h:308:20
    [DllImport(LibraryName)]
    public static extern ulong uv_now(uv_loop_t* param);

    // Function @ uv.h:310:15
    [DllImport(LibraryName)]
    public static extern int uv_backend_fd(uv_loop_t* param);

    // Function @ uv.h:311:15
    [DllImport(LibraryName)]
    public static extern int uv_backend_timeout(uv_loop_t* param);

    // Function @ uv.h:392:15
    [DllImport(LibraryName)]
    public static extern int uv_translate_sys_error(int sys_errno);

    // Function @ uv.h:394:23
    [DllImport(LibraryName)]
    public static extern CString uv_strerror(int err);

    // Function @ uv.h:395:17
    [DllImport(LibraryName)]
    public static extern CString uv_strerror_r(int err, CString buf, ulong buflen);

    // Function @ uv.h:397:23
    [DllImport(LibraryName)]
    public static extern CString uv_err_name(int err);

    // Function @ uv.h:398:17
    [DllImport(LibraryName)]
    public static extern CString uv_err_name_r(int err, CString buf, ulong buflen);

    // Function @ uv.h:420:15
    [DllImport(LibraryName)]
    public static extern int uv_shutdown(uv_shutdown_t* req, uv_stream_t* handle, uv_shutdown_cb cb);

    // Function @ uv.h:452:18
    [DllImport(LibraryName)]
    public static extern ulong uv_handle_size(uv_handle_type type);

    // Function @ uv.h:453:26
    [DllImport(LibraryName)]
    public static extern uv_handle_type uv_handle_get_type(uv_handle_t* handle);

    // Function @ uv.h:454:23
    [DllImport(LibraryName)]
    public static extern CString uv_handle_type_name(uv_handle_type type);

    // Function @ uv.h:455:17
    [DllImport(LibraryName)]
    public static extern void* uv_handle_get_data(uv_handle_t* handle);

    // Function @ uv.h:456:22
    [DllImport(LibraryName)]
    public static extern uv_loop_t* uv_handle_get_loop(uv_handle_t* handle);

    // Function @ uv.h:457:16
    [DllImport(LibraryName)]
    public static extern void uv_handle_set_data(uv_handle_t* handle, void* data);

    // Function @ uv.h:459:18
    [DllImport(LibraryName)]
    public static extern ulong uv_req_size(uv_req_type type);

    // Function @ uv.h:460:17
    [DllImport(LibraryName)]
    public static extern void* uv_req_get_data(uv_req_t* req);

    // Function @ uv.h:461:16
    [DllImport(LibraryName)]
    public static extern void uv_req_set_data(uv_req_t* req, void* data);

    // Function @ uv.h:462:23
    [DllImport(LibraryName)]
    public static extern uv_req_type uv_req_get_type(uv_req_t* req);

    // Function @ uv.h:463:23
    [DllImport(LibraryName)]
    public static extern CString uv_req_type_name(uv_req_type type);

    // Function @ uv.h:465:15
    [DllImport(LibraryName)]
    public static extern int uv_is_active(uv_handle_t* handle);

    // Function @ uv.h:467:16
    [DllImport(LibraryName)]
    public static extern void uv_walk(uv_loop_t* loop, uv_walk_cb walk_cb, void* arg);

    // Function @ uv.h:470:16
    [DllImport(LibraryName)]
    public static extern void uv_print_all_handles(uv_loop_t* loop, nint stream);

    // Function @ uv.h:471:16
    [DllImport(LibraryName)]
    public static extern void uv_print_active_handles(uv_loop_t* loop, nint stream);

    // Function @ uv.h:473:16
    [DllImport(LibraryName)]
    public static extern void uv_close(uv_handle_t* handle, uv_close_cb close_cb);

    // Function @ uv.h:475:15
    [DllImport(LibraryName)]
    public static extern int uv_send_buffer_size(uv_handle_t* handle, long* value);

    // Function @ uv.h:476:15
    [DllImport(LibraryName)]
    public static extern int uv_recv_buffer_size(uv_handle_t* handle, long* value);

    // Function @ uv.h:478:15
    [DllImport(LibraryName)]
    public static extern int uv_fileno(uv_handle_t* handle, uv_os_fd_t* fd);

    // Function @ uv.h:480:20
    [DllImport(LibraryName)]
    public static extern uv_buf_t uv_buf_init(CString @base, uint len);

    // Function @ uv.h:482:15
    [DllImport(LibraryName)]
    public static extern int uv_pipe(uv_file* fds, int read_flags, int write_flags);

    // Function @ uv.h:483:15
    [DllImport(LibraryName)]
    public static extern int uv_socketpair(int type, int protocol, uv_os_sock_t* socket_vector, int flags0, int flags1);

    // Function @ uv.h:509:18
    [DllImport(LibraryName)]
    public static extern ulong uv_stream_get_write_queue_size(uv_stream_t* stream);

    // Function @ uv.h:511:15
    [DllImport(LibraryName)]
    public static extern int uv_listen(uv_stream_t* stream, int backlog, uv_connection_cb cb);

    // Function @ uv.h:512:15
    [DllImport(LibraryName)]
    public static extern int uv_accept(uv_stream_t* server, uv_stream_t* client);

    // Function @ uv.h:514:15
    [DllImport(LibraryName)]
    public static extern int uv_read_start(uv_stream_t* param, uv_alloc_cb alloc_cb, uv_read_cb read_cb);

    // Function @ uv.h:517:15
    [DllImport(LibraryName)]
    public static extern int uv_read_stop(uv_stream_t* param);

    // Function @ uv.h:519:15
    [DllImport(LibraryName)]
    public static extern int uv_write(uv_write_t* req, uv_stream_t* handle, uv_buf_t* bufs, uint nbufs, uv_write_cb cb);

    // Function @ uv.h:524:15
    [DllImport(LibraryName)]
    public static extern int uv_write2(uv_write_t* req, uv_stream_t* handle, uv_buf_t* bufs, uint nbufs, uv_stream_t* send_handle, uv_write_cb cb);

    // Function @ uv.h:530:15
    [DllImport(LibraryName)]
    public static extern int uv_try_write(uv_stream_t* handle, uv_buf_t* bufs, uint nbufs);

    // Function @ uv.h:533:15
    [DllImport(LibraryName)]
    public static extern int uv_try_write2(uv_stream_t* handle, uv_buf_t* bufs, uint nbufs, uv_stream_t* send_handle);

    // Function @ uv.h:548:15
    [DllImport(LibraryName)]
    public static extern int uv_is_readable(uv_stream_t* handle);

    // Function @ uv.h:549:15
    [DllImport(LibraryName)]
    public static extern int uv_is_writable(uv_stream_t* handle);

    // Function @ uv.h:551:15
    [DllImport(LibraryName)]
    public static extern int uv_stream_set_blocking(uv_stream_t* handle, int blocking);

    // Function @ uv.h:553:15
    [DllImport(LibraryName)]
    public static extern int uv_is_closing(uv_handle_t* handle);

    // Function @ uv.h:567:15
    [DllImport(LibraryName)]
    public static extern int uv_tcp_init(uv_loop_t* param, uv_tcp_t* handle);

    // Function @ uv.h:568:15
    [DllImport(LibraryName)]
    public static extern int uv_tcp_init_ex(uv_loop_t* param, uv_tcp_t* handle, uint flags);

    // Function @ uv.h:569:15
    [DllImport(LibraryName)]
    public static extern int uv_tcp_open(uv_tcp_t* handle, uv_os_sock_t sock);

    // Function @ uv.h:570:15
    [DllImport(LibraryName)]
    public static extern int uv_tcp_nodelay(uv_tcp_t* handle, int enable);

    // Function @ uv.h:571:15
    [DllImport(LibraryName)]
    public static extern int uv_tcp_keepalive(uv_tcp_t* handle, int enable, uint delay);

    // Function @ uv.h:574:15
    [DllImport(LibraryName)]
    public static extern int uv_tcp_simultaneous_accepts(uv_tcp_t* handle, int enable);

    // Function @ uv.h:581:15
    [DllImport(LibraryName)]
    public static extern int uv_tcp_bind(uv_tcp_t* handle, sockaddr* addr, uint flags);

    // Function @ uv.h:584:15
    [DllImport(LibraryName)]
    public static extern int uv_tcp_getsockname(uv_tcp_t* handle, sockaddr* name, long* namelen);

    // Function @ uv.h:587:15
    [DllImport(LibraryName)]
    public static extern int uv_tcp_getpeername(uv_tcp_t* handle, sockaddr* name, long* namelen);

    // Function @ uv.h:590:15
    [DllImport(LibraryName)]
    public static extern int uv_tcp_close_reset(uv_tcp_t* handle, uv_close_cb close_cb);

    // Function @ uv.h:591:15
    [DllImport(LibraryName)]
    public static extern int uv_tcp_connect(uv_connect_t* req, uv_tcp_t* handle, sockaddr* addr, uv_connect_cb cb);

    // Function @ uv.h:682:15
    [DllImport(LibraryName)]
    public static extern int uv_udp_init(uv_loop_t* param, uv_udp_t* handle);

    // Function @ uv.h:683:15
    [DllImport(LibraryName)]
    public static extern int uv_udp_init_ex(uv_loop_t* param, uv_udp_t* handle, uint flags);

    // Function @ uv.h:684:15
    [DllImport(LibraryName)]
    public static extern int uv_udp_open(uv_udp_t* handle, uv_os_sock_t sock);

    // Function @ uv.h:685:15
    [DllImport(LibraryName)]
    public static extern int uv_udp_bind(uv_udp_t* handle, sockaddr* addr, uint flags);

    // Function @ uv.h:688:15
    [DllImport(LibraryName)]
    public static extern int uv_udp_connect(uv_udp_t* handle, sockaddr* addr);

    // Function @ uv.h:690:15
    [DllImport(LibraryName)]
    public static extern int uv_udp_getpeername(uv_udp_t* handle, sockaddr* name, long* namelen);

    // Function @ uv.h:693:15
    [DllImport(LibraryName)]
    public static extern int uv_udp_getsockname(uv_udp_t* handle, sockaddr* name, long* namelen);

    // Function @ uv.h:696:15
    [DllImport(LibraryName)]
    public static extern int uv_udp_set_membership(uv_udp_t* handle, CString multicast_addr, CString interface_addr, uv_membership membership);

    // Function @ uv.h:700:15
    [DllImport(LibraryName)]
    public static extern int uv_udp_set_source_membership(uv_udp_t* handle, CString multicast_addr, CString interface_addr, CString source_addr, uv_membership membership);

    // Function @ uv.h:705:15
    [DllImport(LibraryName)]
    public static extern int uv_udp_set_multicast_loop(uv_udp_t* handle, int on);

    // Function @ uv.h:706:15
    [DllImport(LibraryName)]
    public static extern int uv_udp_set_multicast_ttl(uv_udp_t* handle, int ttl);

    // Function @ uv.h:707:15
    [DllImport(LibraryName)]
    public static extern int uv_udp_set_multicast_interface(uv_udp_t* handle, CString interface_addr);

    // Function @ uv.h:709:15
    [DllImport(LibraryName)]
    public static extern int uv_udp_set_broadcast(uv_udp_t* handle, int on);

    // Function @ uv.h:710:15
    [DllImport(LibraryName)]
    public static extern int uv_udp_set_ttl(uv_udp_t* handle, int ttl);

    // Function @ uv.h:711:15
    [DllImport(LibraryName)]
    public static extern int uv_udp_send(uv_udp_send_t* req, uv_udp_t* handle, uv_buf_t* bufs, uint nbufs, sockaddr* addr, uv_udp_send_cb send_cb);

    // Function @ uv.h:717:15
    [DllImport(LibraryName)]
    public static extern int uv_udp_try_send(uv_udp_t* handle, uv_buf_t* bufs, uint nbufs, sockaddr* addr);

    // Function @ uv.h:721:15
    [DllImport(LibraryName)]
    public static extern int uv_udp_recv_start(uv_udp_t* handle, uv_alloc_cb alloc_cb, uv_udp_recv_cb recv_cb);

    // Function @ uv.h:724:15
    [DllImport(LibraryName)]
    public static extern int uv_udp_using_recvmmsg(uv_udp_t* handle);

    // Function @ uv.h:725:15
    [DllImport(LibraryName)]
    public static extern int uv_udp_recv_stop(uv_udp_t* handle);

    // Function @ uv.h:726:18
    [DllImport(LibraryName)]
    public static extern ulong uv_udp_get_send_queue_size(uv_udp_t* handle);

    // Function @ uv.h:727:18
    [DllImport(LibraryName)]
    public static extern ulong uv_udp_get_send_queue_count(uv_udp_t* handle);

    // Function @ uv.h:763:15
    [DllImport(LibraryName)]
    public static extern int uv_tty_init(uv_loop_t* param, uv_tty_t* param2, uv_file fd, int readable);

    // Function @ uv.h:764:15
    [DllImport(LibraryName)]
    public static extern int uv_tty_set_mode(uv_tty_t* param, uv_tty_mode_t mode);

    // Function @ uv.h:765:15
    [DllImport(LibraryName)]
    public static extern int uv_tty_reset_mode();

    // Function @ uv.h:766:15
    [DllImport(LibraryName)]
    public static extern int uv_tty_get_winsize(uv_tty_t* param, long* width, long* height);

    // Function @ uv.h:767:16
    [DllImport(LibraryName)]
    public static extern void uv_tty_set_vterm_state(uv_tty_vtermstate_t state);

    // Function @ uv.h:768:15
    [DllImport(LibraryName)]
    public static extern int uv_tty_get_vterm_state(uv_tty_vtermstate_t* state);

    // Function @ uv.h:780:26
    [DllImport(LibraryName)]
    public static extern uv_handle_type uv_guess_handle(uv_file file);

    // Function @ uv.h:795:15
    [DllImport(LibraryName)]
    public static extern int uv_pipe_init(uv_loop_t* param, uv_pipe_t* handle, int ipc);

    // Function @ uv.h:796:15
    [DllImport(LibraryName)]
    public static extern int uv_pipe_open(uv_pipe_t* param, uv_file file);

    // Function @ uv.h:797:15
    [DllImport(LibraryName)]
    public static extern int uv_pipe_bind(uv_pipe_t* handle, CString name);

    // Function @ uv.h:798:16
    [DllImport(LibraryName)]
    public static extern void uv_pipe_connect(uv_connect_t* req, uv_pipe_t* handle, CString name, uv_connect_cb cb);

    // Function @ uv.h:802:15
    [DllImport(LibraryName)]
    public static extern int uv_pipe_getsockname(uv_pipe_t* handle, CString buffer, ulong* size);

    // Function @ uv.h:805:15
    [DllImport(LibraryName)]
    public static extern int uv_pipe_getpeername(uv_pipe_t* handle, CString buffer, ulong* size);

    // Function @ uv.h:808:16
    [DllImport(LibraryName)]
    public static extern void uv_pipe_pending_instances(uv_pipe_t* handle, int count);

    // Function @ uv.h:809:15
    [DllImport(LibraryName)]
    public static extern int uv_pipe_pending_count(uv_pipe_t* handle);

    // Function @ uv.h:810:26
    [DllImport(LibraryName)]
    public static extern uv_handle_type uv_pipe_pending_type(uv_pipe_t* handle);

    // Function @ uv.h:811:15
    [DllImport(LibraryName)]
    public static extern int uv_pipe_chmod(uv_pipe_t* handle, int flags);

    // Function @ uv.h:827:15
    [DllImport(LibraryName)]
    public static extern int uv_poll_init(uv_loop_t* loop, uv_poll_t* handle, int fd);

    // Function @ uv.h:828:15
    [DllImport(LibraryName)]
    public static extern int uv_poll_init_socket(uv_loop_t* loop, uv_poll_t* handle, uv_os_sock_t socket);

    // Function @ uv.h:831:15
    [DllImport(LibraryName)]
    public static extern int uv_poll_start(uv_poll_t* handle, int events, uv_poll_cb cb);

    // Function @ uv.h:832:15
    [DllImport(LibraryName)]
    public static extern int uv_poll_stop(uv_poll_t* handle);

    // Function @ uv.h:840:15
    [DllImport(LibraryName)]
    public static extern int uv_prepare_init(uv_loop_t* param, uv_prepare_t* prepare);

    // Function @ uv.h:841:15
    [DllImport(LibraryName)]
    public static extern int uv_prepare_start(uv_prepare_t* prepare, uv_prepare_cb cb);

    // Function @ uv.h:842:15
    [DllImport(LibraryName)]
    public static extern int uv_prepare_stop(uv_prepare_t* prepare);

    // Function @ uv.h:850:15
    [DllImport(LibraryName)]
    public static extern int uv_check_init(uv_loop_t* param, uv_check_t* check);

    // Function @ uv.h:851:15
    [DllImport(LibraryName)]
    public static extern int uv_check_start(uv_check_t* check, uv_check_cb cb);

    // Function @ uv.h:852:15
    [DllImport(LibraryName)]
    public static extern int uv_check_stop(uv_check_t* check);

    // Function @ uv.h:860:15
    [DllImport(LibraryName)]
    public static extern int uv_idle_init(uv_loop_t* param, uv_idle_t* idle);

    // Function @ uv.h:861:15
    [DllImport(LibraryName)]
    public static extern int uv_idle_start(uv_idle_t* idle, uv_idle_cb cb);

    // Function @ uv.h:862:15
    [DllImport(LibraryName)]
    public static extern int uv_idle_stop(uv_idle_t* idle);

    // Function @ uv.h:870:15
    [DllImport(LibraryName)]
    public static extern int uv_async_init(uv_loop_t* param, uv_async_t* async, uv_async_cb async_cb);

    // Function @ uv.h:873:15
    [DllImport(LibraryName)]
    public static extern int uv_async_send(uv_async_t* async);

    // Function @ uv.h:886:15
    [DllImport(LibraryName)]
    public static extern int uv_timer_init(uv_loop_t* param, uv_timer_t* handle);

    // Function @ uv.h:887:15
    [DllImport(LibraryName)]
    public static extern int uv_timer_start(uv_timer_t* handle, uv_timer_cb cb, ulong timeout, ulong repeat);

    // Function @ uv.h:891:15
    [DllImport(LibraryName)]
    public static extern int uv_timer_stop(uv_timer_t* handle);

    // Function @ uv.h:892:15
    [DllImport(LibraryName)]
    public static extern int uv_timer_again(uv_timer_t* handle);

    // Function @ uv.h:893:16
    [DllImport(LibraryName)]
    public static extern void uv_timer_set_repeat(uv_timer_t* handle, ulong repeat);

    // Function @ uv.h:894:20
    [DllImport(LibraryName)]
    public static extern ulong uv_timer_get_repeat(uv_timer_t* handle);

    // Function @ uv.h:895:20
    [DllImport(LibraryName)]
    public static extern ulong uv_timer_get_due_in(uv_timer_t* handle);

    // Function @ uv.h:912:15
    [DllImport(LibraryName)]
    public static extern int uv_getaddrinfo(uv_loop_t* loop, uv_getaddrinfo_t* req, uv_getaddrinfo_cb getaddrinfo_cb, CString node, CString service, addrinfo* hints);

    // Function @ uv.h:918:16
    [DllImport(LibraryName)]
    public static extern void uv_freeaddrinfo(addrinfo* ai);

    // Function @ uv.h:934:15
    [DllImport(LibraryName)]
    public static extern int uv_getnameinfo(uv_loop_t* loop, uv_getnameinfo_t* req, uv_getnameinfo_cb getnameinfo_cb, sockaddr* addr, int flags);

    // Function @ uv.h:1079:15
    [DllImport(LibraryName)]
    public static extern int uv_spawn(uv_loop_t* loop, uv_process_t* handle, uv_process_options_t* options);

    // Function @ uv.h:1082:15
    [DllImport(LibraryName)]
    public static extern int uv_process_kill(uv_process_t* param, int signum);

    // Function @ uv.h:1083:15
    [DllImport(LibraryName)]
    public static extern int uv_kill(int pid, int signum);

    // Function @ uv.h:1084:20
    [DllImport(LibraryName)]
    public static extern uv_pid_t uv_process_get_pid(uv_process_t* param);

    // Function @ uv.h:1098:15
    [DllImport(LibraryName)]
    public static extern int uv_queue_work(uv_loop_t* loop, uv_work_t* req, uv_work_cb work_cb, uv_after_work_cb after_work_cb);

    // Function @ uv.h:1103:15
    [DllImport(LibraryName)]
    public static extern int uv_cancel(uv_req_t* req);

    // Function @ uv.h:1179:18
    [DllImport(LibraryName)]
    public static extern CString* uv_setup_args(int argc, CString* argv);

    // Function @ uv.h:1180:15
    [DllImport(LibraryName)]
    public static extern int uv_get_process_title(CString buffer, ulong size);

    // Function @ uv.h:1181:15
    [DllImport(LibraryName)]
    public static extern int uv_set_process_title(CString title);

    // Function @ uv.h:1182:15
    [DllImport(LibraryName)]
    public static extern int uv_resident_set_memory(ulong* rss);

    // Function @ uv.h:1183:15
    [DllImport(LibraryName)]
    public static extern int uv_uptime(double* uptime);

    // Function @ uv.h:1184:22
    [DllImport(LibraryName)]
    public static extern uv_os_fd_t uv_get_osfhandle(int fd);

    // Function @ uv.h:1185:15
    [DllImport(LibraryName)]
    public static extern int uv_open_osfhandle(uv_os_fd_t os_fd);

    // Function @ uv.h:1216:15
    [DllImport(LibraryName)]
    public static extern int uv_getrusage(uv_rusage_t* rusage);

    // Function @ uv.h:1218:15
    [DllImport(LibraryName)]
    public static extern int uv_os_homedir(CString buffer, ulong* size);

    // Function @ uv.h:1219:15
    [DllImport(LibraryName)]
    public static extern int uv_os_tmpdir(CString buffer, ulong* size);

    // Function @ uv.h:1220:15
    [DllImport(LibraryName)]
    public static extern int uv_os_get_passwd(uv_passwd_t* pwd);

    // Function @ uv.h:1221:16
    [DllImport(LibraryName)]
    public static extern void uv_os_free_passwd(uv_passwd_t* pwd);

    // Function @ uv.h:1222:20
    [DllImport(LibraryName)]
    public static extern uv_pid_t uv_os_getpid();

    // Function @ uv.h:1223:20
    [DllImport(LibraryName)]
    public static extern uv_pid_t uv_os_getppid();

    // Function @ uv.h:1242:15
    [DllImport(LibraryName)]
    public static extern int uv_os_getpriority(uv_pid_t pid, long* priority);

    // Function @ uv.h:1243:15
    [DllImport(LibraryName)]
    public static extern int uv_os_setpriority(uv_pid_t pid, int priority);

    // Function @ uv.h:1245:15
    [DllImport(LibraryName)]
    public static extern int uv_cpu_info(uv_cpu_info_t** cpu_infos, long* count);

    // Function @ uv.h:1246:16
    [DllImport(LibraryName)]
    public static extern void uv_free_cpu_info(uv_cpu_info_t* cpu_infos, int count);

    // Function @ uv.h:1248:15
    [DllImport(LibraryName)]
    public static extern int uv_interface_addresses(uv_interface_address_t** addresses, long* count);

    // Function @ uv.h:1250:16
    [DllImport(LibraryName)]
    public static extern void uv_free_interface_addresses(uv_interface_address_t* addresses, int count);

    // Function @ uv.h:1258:15
    [DllImport(LibraryName)]
    public static extern int uv_os_environ(uv_env_item_t** envitems, long* count);

    // Function @ uv.h:1259:16
    [DllImport(LibraryName)]
    public static extern void uv_os_free_environ(uv_env_item_t* envitems, int count);

    // Function @ uv.h:1260:15
    [DllImport(LibraryName)]
    public static extern int uv_os_getenv(CString name, CString buffer, ulong* size);

    // Function @ uv.h:1261:15
    [DllImport(LibraryName)]
    public static extern int uv_os_setenv(CString name, CString value);

    // Function @ uv.h:1262:15
    [DllImport(LibraryName)]
    public static extern int uv_os_unsetenv(CString name);

    // Function @ uv.h:1275:15
    [DllImport(LibraryName)]
    public static extern int uv_os_gethostname(CString buffer, ulong* size);

    // Function @ uv.h:1277:15
    [DllImport(LibraryName)]
    public static extern int uv_os_uname(uv_utsname_t* buffer);

    // Function @ uv.h:1279:20
    [DllImport(LibraryName)]
    public static extern ulong uv_metrics_idle_time(uv_loop_t* loop);

    // Function @ uv.h:1342:22
    [DllImport(LibraryName)]
    public static extern uv_fs_type uv_fs_get_type(uv_fs_t* param);

    // Function @ uv.h:1343:19
    [DllImport(LibraryName)]
    public static extern long uv_fs_get_result(uv_fs_t* param);

    // Function @ uv.h:1344:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_get_system_error(uv_fs_t* param);

    // Function @ uv.h:1345:17
    [DllImport(LibraryName)]
    public static extern void* uv_fs_get_ptr(uv_fs_t* param);

    // Function @ uv.h:1346:23
    [DllImport(LibraryName)]
    public static extern CString uv_fs_get_path(uv_fs_t* param);

    // Function @ uv.h:1347:22
    [DllImport(LibraryName)]
    public static extern uv_stat_t* uv_fs_get_statbuf(uv_fs_t* param);

    // Function @ uv.h:1349:16
    [DllImport(LibraryName)]
    public static extern void uv_fs_req_cleanup(uv_fs_t* req);

    // Function @ uv.h:1350:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_close(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb);

    // Function @ uv.h:1354:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_open(uv_loop_t* loop, uv_fs_t* req, CString path, int flags, int mode, uv_fs_cb cb);

    // Function @ uv.h:1360:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_read(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_buf_t* bufs, uint nbufs, long offset, uv_fs_cb cb);

    // Function @ uv.h:1367:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_unlink(uv_loop_t* loop, uv_fs_t* req, CString path, uv_fs_cb cb);

    // Function @ uv.h:1371:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_write(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_buf_t* bufs, uint nbufs, long offset, uv_fs_cb cb);

    // Function @ uv.h:1396:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_copyfile(uv_loop_t* loop, uv_fs_t* req, CString path, CString new_path, int flags, uv_fs_cb cb);

    // Function @ uv.h:1402:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_mkdir(uv_loop_t* loop, uv_fs_t* req, CString path, int mode, uv_fs_cb cb);

    // Function @ uv.h:1407:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_mkdtemp(uv_loop_t* loop, uv_fs_t* req, CString tpl, uv_fs_cb cb);

    // Function @ uv.h:1411:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_mkstemp(uv_loop_t* loop, uv_fs_t* req, CString tpl, uv_fs_cb cb);

    // Function @ uv.h:1415:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_rmdir(uv_loop_t* loop, uv_fs_t* req, CString path, uv_fs_cb cb);

    // Function @ uv.h:1419:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_scandir(uv_loop_t* loop, uv_fs_t* req, CString path, int flags, uv_fs_cb cb);

    // Function @ uv.h:1424:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_scandir_next(uv_fs_t* req, uv_dirent_t* ent);

    // Function @ uv.h:1426:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_opendir(uv_loop_t* loop, uv_fs_t* req, CString path, uv_fs_cb cb);

    // Function @ uv.h:1430:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_readdir(uv_loop_t* loop, uv_fs_t* req, uv_dir_t* dir, uv_fs_cb cb);

    // Function @ uv.h:1434:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_closedir(uv_loop_t* loop, uv_fs_t* req, uv_dir_t* dir, uv_fs_cb cb);

    // Function @ uv.h:1438:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_stat(uv_loop_t* loop, uv_fs_t* req, CString path, uv_fs_cb cb);

    // Function @ uv.h:1442:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_fstat(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb);

    // Function @ uv.h:1446:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_rename(uv_loop_t* loop, uv_fs_t* req, CString path, CString new_path, uv_fs_cb cb);

    // Function @ uv.h:1451:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_fsync(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb);

    // Function @ uv.h:1455:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_fdatasync(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb);

    // Function @ uv.h:1459:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_ftruncate(uv_loop_t* loop, uv_fs_t* req, uv_file file, long offset, uv_fs_cb cb);

    // Function @ uv.h:1464:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_sendfile(uv_loop_t* loop, uv_fs_t* req, uv_file out_fd, uv_file in_fd, long in_offset, ulong length, uv_fs_cb cb);

    // Function @ uv.h:1471:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_access(uv_loop_t* loop, uv_fs_t* req, CString path, int mode, uv_fs_cb cb);

    // Function @ uv.h:1476:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_chmod(uv_loop_t* loop, uv_fs_t* req, CString path, int mode, uv_fs_cb cb);

    // Function @ uv.h:1481:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_utime(uv_loop_t* loop, uv_fs_t* req, CString path, double atime, double mtime, uv_fs_cb cb);

    // Function @ uv.h:1487:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_futime(uv_loop_t* loop, uv_fs_t* req, uv_file file, double atime, double mtime, uv_fs_cb cb);

    // Function @ uv.h:1493:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_lutime(uv_loop_t* loop, uv_fs_t* req, CString path, double atime, double mtime, uv_fs_cb cb);

    // Function @ uv.h:1499:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_lstat(uv_loop_t* loop, uv_fs_t* req, CString path, uv_fs_cb cb);

    // Function @ uv.h:1503:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_link(uv_loop_t* loop, uv_fs_t* req, CString path, CString new_path, uv_fs_cb cb);

    // Function @ uv.h:1521:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_symlink(uv_loop_t* loop, uv_fs_t* req, CString path, CString new_path, int flags, uv_fs_cb cb);

    // Function @ uv.h:1527:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_readlink(uv_loop_t* loop, uv_fs_t* req, CString path, uv_fs_cb cb);

    // Function @ uv.h:1531:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_realpath(uv_loop_t* loop, uv_fs_t* req, CString path, uv_fs_cb cb);

    // Function @ uv.h:1535:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_fchmod(uv_loop_t* loop, uv_fs_t* req, uv_file file, int mode, uv_fs_cb cb);

    // Function @ uv.h:1540:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_chown(uv_loop_t* loop, uv_fs_t* req, CString path, uv_uid_t uid, uv_gid_t gid, uv_fs_cb cb);

    // Function @ uv.h:1546:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_fchown(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_uid_t uid, uv_gid_t gid, uv_fs_cb cb);

    // Function @ uv.h:1552:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_lchown(uv_loop_t* loop, uv_fs_t* req, CString path, uv_uid_t uid, uv_gid_t gid, uv_fs_cb cb);

    // Function @ uv.h:1558:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_statfs(uv_loop_t* loop, uv_fs_t* req, CString path, uv_fs_cb cb);

    // Function @ uv.h:1587:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_poll_init(uv_loop_t* loop, uv_fs_poll_t* handle);

    // Function @ uv.h:1588:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_poll_start(uv_fs_poll_t* handle, uv_fs_poll_cb poll_cb, CString path, uint interval);

    // Function @ uv.h:1592:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_poll_stop(uv_fs_poll_t* handle);

    // Function @ uv.h:1593:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_poll_getpath(uv_fs_poll_t* handle, CString buffer, ulong* size);

    // Function @ uv.h:1605:15
    [DllImport(LibraryName)]
    public static extern int uv_signal_init(uv_loop_t* loop, uv_signal_t* handle);

    // Function @ uv.h:1606:15
    [DllImport(LibraryName)]
    public static extern int uv_signal_start(uv_signal_t* handle, uv_signal_cb signal_cb, int signum);

    // Function @ uv.h:1609:15
    [DllImport(LibraryName)]
    public static extern int uv_signal_start_oneshot(uv_signal_t* handle, uv_signal_cb signal_cb, int signum);

    // Function @ uv.h:1612:15
    [DllImport(LibraryName)]
    public static extern int uv_signal_stop(uv_signal_t* handle);

    // Function @ uv.h:1614:16
    [DllImport(LibraryName)]
    public static extern void uv_loadavg(double* avg);

    // Function @ uv.h:1648:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_event_init(uv_loop_t* loop, uv_fs_event_t* handle);

    // Function @ uv.h:1649:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_event_start(uv_fs_event_t* handle, uv_fs_event_cb cb, CString path, uint flags);

    // Function @ uv.h:1653:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_event_stop(uv_fs_event_t* handle);

    // Function @ uv.h:1654:15
    [DllImport(LibraryName)]
    public static extern int uv_fs_event_getpath(uv_fs_event_t* handle, CString buffer, ulong* size);

    // Function @ uv.h:1658:15
    [DllImport(LibraryName)]
    public static extern int uv_ip4_addr(CString ip, int port, sockaddr_in* addr);

    // Function @ uv.h:1659:15
    [DllImport(LibraryName)]
    public static extern int uv_ip6_addr(CString ip, int port, sockaddr_in6* addr);

    // Function @ uv.h:1661:15
    [DllImport(LibraryName)]
    public static extern int uv_ip4_name(sockaddr_in* src, CString dst, ulong size);

    // Function @ uv.h:1662:15
    [DllImport(LibraryName)]
    public static extern int uv_ip6_name(sockaddr_in6* src, CString dst, ulong size);

    // Function @ uv.h:1663:15
    [DllImport(LibraryName)]
    public static extern int uv_ip_name(sockaddr* src, CString dst, ulong size);

    // Function @ uv.h:1665:15
    [DllImport(LibraryName)]
    public static extern int uv_inet_ntop(int af, void* src, CString dst, ulong size);

    // Function @ uv.h:1666:15
    [DllImport(LibraryName)]
    public static extern int uv_inet_pton(int af, CString src, void* dst);

    // Function @ uv.h:1681:15
    [DllImport(LibraryName)]
    public static extern int uv_random(uv_loop_t* loop, uv_random_t* req, void* buf, ulong buflen, uint flags, uv_random_cb cb);

    // Function @ uv.h:1696:15
    [DllImport(LibraryName)]
    public static extern int uv_if_indextoname(uint ifindex, CString buffer, ulong* size);

    // Function @ uv.h:1699:15
    [DllImport(LibraryName)]
    public static extern int uv_if_indextoiid(uint ifindex, CString buffer, ulong* size);

    // Function @ uv.h:1703:15
    [DllImport(LibraryName)]
    public static extern int uv_exepath(CString buffer, ulong* size);

    // Function @ uv.h:1705:15
    [DllImport(LibraryName)]
    public static extern int uv_cwd(CString buffer, ulong* size);

    // Function @ uv.h:1707:15
    [DllImport(LibraryName)]
    public static extern int uv_chdir(CString dir);

    // Function @ uv.h:1709:20
    [DllImport(LibraryName)]
    public static extern ulong uv_get_free_memory();

    // Function @ uv.h:1710:20
    [DllImport(LibraryName)]
    public static extern ulong uv_get_total_memory();

    // Function @ uv.h:1711:20
    [DllImport(LibraryName)]
    public static extern ulong uv_get_constrained_memory();

    // Function @ uv.h:1713:20
    [DllImport(LibraryName)]
    public static extern ulong uv_hrtime();

    // Function @ uv.h:1714:16
    [DllImport(LibraryName)]
    public static extern void uv_sleep(uint msec);

    // Function @ uv.h:1716:16
    [DllImport(LibraryName)]
    public static extern void uv_disable_stdio_inheritance();

    // Function @ uv.h:1718:15
    [DllImport(LibraryName)]
    public static extern int uv_dlopen(CString filename, uv_lib_t* lib);

    // Function @ uv.h:1719:16
    [DllImport(LibraryName)]
    public static extern void uv_dlclose(uv_lib_t* lib);

    // Function @ uv.h:1720:15
    [DllImport(LibraryName)]
    public static extern int uv_dlsym(uv_lib_t* lib, CString name, void** ptr);

    // Function @ uv.h:1721:23
    [DllImport(LibraryName)]
    public static extern CString uv_dlerror(uv_lib_t* lib);

    // Function @ uv.h:1723:15
    [DllImport(LibraryName)]
    public static extern int uv_mutex_init(uv_mutex_t* handle);

    // Function @ uv.h:1724:15
    [DllImport(LibraryName)]
    public static extern int uv_mutex_init_recursive(uv_mutex_t* handle);

    // Function @ uv.h:1725:16
    [DllImport(LibraryName)]
    public static extern void uv_mutex_destroy(uv_mutex_t* handle);

    // Function @ uv.h:1726:16
    [DllImport(LibraryName)]
    public static extern void uv_mutex_lock(uv_mutex_t* handle);

    // Function @ uv.h:1727:15
    [DllImport(LibraryName)]
    public static extern int uv_mutex_trylock(uv_mutex_t* handle);

    // Function @ uv.h:1728:16
    [DllImport(LibraryName)]
    public static extern void uv_mutex_unlock(uv_mutex_t* handle);

    // Function @ uv.h:1730:15
    [DllImport(LibraryName)]
    public static extern int uv_rwlock_init(uv_rwlock_t* rwlock);

    // Function @ uv.h:1731:16
    [DllImport(LibraryName)]
    public static extern void uv_rwlock_destroy(uv_rwlock_t* rwlock);

    // Function @ uv.h:1732:16
    [DllImport(LibraryName)]
    public static extern void uv_rwlock_rdlock(uv_rwlock_t* rwlock);

    // Function @ uv.h:1733:15
    [DllImport(LibraryName)]
    public static extern int uv_rwlock_tryrdlock(uv_rwlock_t* rwlock);

    // Function @ uv.h:1734:16
    [DllImport(LibraryName)]
    public static extern void uv_rwlock_rdunlock(uv_rwlock_t* rwlock);

    // Function @ uv.h:1735:16
    [DllImport(LibraryName)]
    public static extern void uv_rwlock_wrlock(uv_rwlock_t* rwlock);

    // Function @ uv.h:1736:15
    [DllImport(LibraryName)]
    public static extern int uv_rwlock_trywrlock(uv_rwlock_t* rwlock);

    // Function @ uv.h:1737:16
    [DllImport(LibraryName)]
    public static extern void uv_rwlock_wrunlock(uv_rwlock_t* rwlock);

    // Function @ uv.h:1739:15
    [DllImport(LibraryName)]
    public static extern int uv_sem_init(uv_sem_t* sem, uint value);

    // Function @ uv.h:1740:16
    [DllImport(LibraryName)]
    public static extern void uv_sem_destroy(uv_sem_t* sem);

    // Function @ uv.h:1741:16
    [DllImport(LibraryName)]
    public static extern void uv_sem_post(uv_sem_t* sem);

    // Function @ uv.h:1742:16
    [DllImport(LibraryName)]
    public static extern void uv_sem_wait(uv_sem_t* sem);

    // Function @ uv.h:1743:15
    [DllImport(LibraryName)]
    public static extern int uv_sem_trywait(uv_sem_t* sem);

    // Function @ uv.h:1745:15
    [DllImport(LibraryName)]
    public static extern int uv_cond_init(uv_cond_t* cond);

    // Function @ uv.h:1746:16
    [DllImport(LibraryName)]
    public static extern void uv_cond_destroy(uv_cond_t* cond);

    // Function @ uv.h:1747:16
    [DllImport(LibraryName)]
    public static extern void uv_cond_signal(uv_cond_t* cond);

    // Function @ uv.h:1748:16
    [DllImport(LibraryName)]
    public static extern void uv_cond_broadcast(uv_cond_t* cond);

    // Function @ uv.h:1750:15
    [DllImport(LibraryName)]
    public static extern int uv_barrier_init(uv_barrier_t* barrier, uint count);

    // Function @ uv.h:1751:16
    [DllImport(LibraryName)]
    public static extern void uv_barrier_destroy(uv_barrier_t* barrier);

    // Function @ uv.h:1752:15
    [DllImport(LibraryName)]
    public static extern int uv_barrier_wait(uv_barrier_t* barrier);

    // Function @ uv.h:1754:16
    [DllImport(LibraryName)]
    public static extern void uv_cond_wait(uv_cond_t* cond, uv_mutex_t* mutex);

    // Function @ uv.h:1755:15
    [DllImport(LibraryName)]
    public static extern int uv_cond_timedwait(uv_cond_t* cond, uv_mutex_t* mutex, ulong timeout);

    // Function @ uv.h:1759:16
    [DllImport(LibraryName)]
    public static extern void uv_once(uv_once_t* guard, FnPtr_UV_Void callback);

    // Function @ uv.h:1761:15
    [DllImport(LibraryName)]
    public static extern int uv_key_create(uv_key_t* key);

    // Function @ uv.h:1762:16
    [DllImport(LibraryName)]
    public static extern void uv_key_delete(uv_key_t* key);

    // Function @ uv.h:1763:17
    [DllImport(LibraryName)]
    public static extern void* uv_key_get(uv_key_t* key);

    // Function @ uv.h:1764:16
    [DllImport(LibraryName)]
    public static extern void uv_key_set(uv_key_t* key, void* value);

    // Function @ uv.h:1766:15
    [DllImport(LibraryName)]
    public static extern int uv_gettimeofday(uv_timeval64_t* tv);

    // Function @ uv.h:1770:15
    [DllImport(LibraryName)]
    public static extern int uv_thread_create(uv_thread_t* tid, uv_thread_cb entry, void* arg);

    // Function @ uv.h:1785:15
    [DllImport(LibraryName)]
    public static extern int uv_thread_create_ex(uv_thread_t* tid, uv_thread_options_t* @params, uv_thread_cb entry, void* arg);

    // Function @ uv.h:1789:23
    [DllImport(LibraryName)]
    public static extern uv_thread_t uv_thread_self();

    // Function @ uv.h:1790:15
    [DllImport(LibraryName)]
    public static extern int uv_thread_join(uv_thread_t* tid);

    // Function @ uv.h:1791:15
    [DllImport(LibraryName)]
    public static extern int uv_thread_equal(uv_thread_t* t1, uv_thread_t* t2);

    // Function @ uv.h:1822:17
    [DllImport(LibraryName)]
    public static extern void* uv_loop_get_data(uv_loop_t* param);

    // Function @ uv.h:1823:16
    [DllImport(LibraryName)]
    public static extern void uv_loop_set_data(uv_loop_t* param, void* data);

    // FunctionPointer @ uv.h:268:17
    [StructLayout(LayoutKind.Sequential)]
    public struct uv_malloc_func
    {
        public delegate* unmanaged<ulong, void*> Pointer;
    }

    // FunctionPointer @ uv.h:269:17
    [StructLayout(LayoutKind.Sequential)]
    public struct uv_realloc_func
    {
        public delegate* unmanaged<void*, ulong, void*> Pointer;
    }

    // FunctionPointer @ uv.h:270:17
    [StructLayout(LayoutKind.Sequential)]
    public struct uv_calloc_func
    {
        public delegate* unmanaged<ulong, ulong, void*> Pointer;
    }

    // FunctionPointer @ uv.h:271:16
    [StructLayout(LayoutKind.Sequential)]
    public struct uv_free_func
    {
        public delegate* unmanaged<void*, void> Pointer;
    }

    // FunctionPointer @ uv.h:321:16
    [StructLayout(LayoutKind.Sequential)]
    public struct uv_shutdown_cb
    {
        public delegate* unmanaged<uv_shutdown_t*, int, void> Pointer;
    }

    // FunctionPointer @ uv.h:331:16
    [StructLayout(LayoutKind.Sequential)]
    public struct uv_walk_cb
    {
        public delegate* unmanaged<uv_handle_t*, void*, void> Pointer;
    }

    // FunctionPointer @ uv.h:323:16
    [StructLayout(LayoutKind.Sequential)]
    public struct uv_close_cb
    {
        public delegate* unmanaged<uv_handle_t*, void> Pointer;
    }

    // FunctionPointer @ uv.h:322:16
    [StructLayout(LayoutKind.Sequential)]
    public struct uv_connection_cb
    {
        public delegate* unmanaged<uv_stream_t*, int, void> Pointer;
    }

    // FunctionPointer @ uv.h:313:16
    [StructLayout(LayoutKind.Sequential)]
    public struct uv_alloc_cb
    {
        public delegate* unmanaged<uv_handle_t*, ulong, uv_buf_t*, void> Pointer;
    }

    // FunctionPointer @ uv.h:316:16
    [StructLayout(LayoutKind.Sequential)]
    public struct uv_read_cb
    {
        public delegate* unmanaged<uv_stream_t*, long, uv_buf_t*, void> Pointer;
    }

    // FunctionPointer @ uv.h:319:16
    [StructLayout(LayoutKind.Sequential)]
    public struct uv_write_cb
    {
        public delegate* unmanaged<uv_write_t*, int, void> Pointer;
    }

    // FunctionPointer @ uv.h:320:16
    [StructLayout(LayoutKind.Sequential)]
    public struct uv_connect_cb
    {
        public delegate* unmanaged<uv_connect_t*, int, void> Pointer;
    }

    // FunctionPointer @ uv.h:651:16
    [StructLayout(LayoutKind.Sequential)]
    public struct uv_udp_send_cb
    {
        public delegate* unmanaged<uv_udp_send_t*, int, void> Pointer;
    }

    // FunctionPointer @ uv.h:652:16
    [StructLayout(LayoutKind.Sequential)]
    public struct uv_udp_recv_cb
    {
        public delegate* unmanaged<uv_udp_t*, long, uv_buf_t*, sockaddr*, uint, void> Pointer;
    }

    // FunctionPointer @ uv.h:324:16
    [StructLayout(LayoutKind.Sequential)]
    public struct uv_poll_cb
    {
        public delegate* unmanaged<uv_poll_t*, int, int, void> Pointer;
    }

    // FunctionPointer @ uv.h:327:16
    [StructLayout(LayoutKind.Sequential)]
    public struct uv_prepare_cb
    {
        public delegate* unmanaged<uv_prepare_t*, void> Pointer;
    }

    // FunctionPointer @ uv.h:328:16
    [StructLayout(LayoutKind.Sequential)]
    public struct uv_check_cb
    {
        public delegate* unmanaged<uv_check_t*, void> Pointer;
    }

    // FunctionPointer @ uv.h:329:16
    [StructLayout(LayoutKind.Sequential)]
    public struct uv_idle_cb
    {
        public delegate* unmanaged<uv_idle_t*, void> Pointer;
    }

    // FunctionPointer @ uv.h:326:16
    [StructLayout(LayoutKind.Sequential)]
    public struct uv_async_cb
    {
        public delegate* unmanaged<uv_async_t*, void> Pointer;
    }

    // FunctionPointer @ uv.h:325:16
    [StructLayout(LayoutKind.Sequential)]
    public struct uv_timer_cb
    {
        public delegate* unmanaged<uv_timer_t*, void> Pointer;
    }

    // FunctionPointer @ uv.h:335:16
    [StructLayout(LayoutKind.Sequential)]
    public struct uv_getaddrinfo_cb
    {
        public delegate* unmanaged<uv_getaddrinfo_t*, int, addrinfo*, void> Pointer;
    }

    // FunctionPointer @ uv.h:338:16
    [StructLayout(LayoutKind.Sequential)]
    public struct uv_getnameinfo_cb
    {
        public delegate* unmanaged<uv_getnameinfo_t*, int, CString, CString, void> Pointer;
    }

    // FunctionPointer @ uv.h:333:16
    [StructLayout(LayoutKind.Sequential)]
    public struct uv_work_cb
    {
        public delegate* unmanaged<uv_work_t*, void> Pointer;
    }

    // FunctionPointer @ uv.h:334:16
    [StructLayout(LayoutKind.Sequential)]
    public struct uv_after_work_cb
    {
        public delegate* unmanaged<uv_work_t*, int, void> Pointer;
    }

    // FunctionPointer @ uv.h:332:16
    [StructLayout(LayoutKind.Sequential)]
    public struct uv_fs_cb
    {
        public delegate* unmanaged<uv_fs_t*, void> Pointer;
    }

    // FunctionPointer @ uv.h:378:16
    [StructLayout(LayoutKind.Sequential)]
    public struct uv_fs_poll_cb
    {
        public delegate* unmanaged<uv_fs_poll_t*, int, uv_stat_t*, uv_stat_t*, void> Pointer;
    }

    // FunctionPointer @ uv.h:383:16
    [StructLayout(LayoutKind.Sequential)]
    public struct uv_signal_cb
    {
        public delegate* unmanaged<uv_signal_t*, int, void> Pointer;
    }

    // FunctionPointer @ uv.h:373:16
    [StructLayout(LayoutKind.Sequential)]
    public struct uv_fs_event_cb
    {
        public delegate* unmanaged<uv_fs_event_t*, CString, int, int, void> Pointer;
    }

    // FunctionPointer @ uv.h:342:16
    [StructLayout(LayoutKind.Sequential)]
    public struct uv_random_cb
    {
        public delegate* unmanaged<uv_random_t*, int, void*, ulong, void> Pointer;
    }

    // FunctionPointer @ uv.h:1759:49
    [StructLayout(LayoutKind.Sequential)]
    public struct FnPtr_UV_Void
    {
        public delegate* unmanaged<void> Pointer;
    }

    // FunctionPointer @ uv.h:1768:16
    [StructLayout(LayoutKind.Sequential)]
    public struct uv_thread_cb
    {
        public delegate* unmanaged<void*, void> Pointer;
    }

    // FunctionPointer @ uv.h:330:16
    [StructLayout(LayoutKind.Sequential)]
    public struct uv_exit_cb
    {
        public delegate* unmanaged<uv_process_t*, long, int, void> Pointer;
    }

    // FunctionPointer @ unix.h:89:16 (uv/unix.h)
    [StructLayout(LayoutKind.Sequential)]
    public struct uv__io_cb
    {
        public delegate* unmanaged<uv_loop_s*, uv__io_s*, uint, void> Pointer;
    }

    // FunctionPointer @ threadpool.h:31:10 (uv/threadpool.h)
    [StructLayout(LayoutKind.Sequential)]
    public struct FnPtr_UV_Uv_workPtr_Void
    {
        public delegate* unmanaged<uv__work*, void> Pointer;
    }

    // FunctionPointer @ threadpool.h:32:10 (uv/threadpool.h)
    [StructLayout(LayoutKind.Sequential)]
    public struct FnPtr_UV_Uv_workPtr_Int_Void
    {
        public delegate* unmanaged<uv__work*, int, void> Pointer;
    }

    // Struct @ uv.h:213:26
    [StructLayout(LayoutKind.Explicit, Size = 848, Pack = 8)]
    public struct uv_loop_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public void* data;

        [FieldOffset(8)] // size = 4, padding = 4
        public uint active_handles;

        [FieldOffset(16)] // size = 16, padding = 0
        public fixed ulong _handle_queue[16 / 8]; // void*[2]

        public Span<nint> handle_queue
        {
            get
            {
                fixed (uv_loop_t* @this = &this)
                {
                    var pointer = &@this->_handle_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(32)] // size = 8, padding = 0
        public uv_loop_t_active_reqs active_reqs;

        [FieldOffset(40)] // size = 8, padding = 0
        public void* internal_fields;

        [FieldOffset(48)] // size = 4, padding = 4
        public uint stop_flag;

        [FieldOffset(56)] // size = 8, padding = 0
        public ulong flags;

        [FieldOffset(64)] // size = 4, padding = 4
        public int backend_fd;

        [FieldOffset(72)] // size = 16, padding = 0
        public fixed ulong _pending_queue[16 / 8]; // void*[2]

        public Span<nint> pending_queue
        {
            get
            {
                fixed (uv_loop_t* @this = &this)
                {
                    var pointer = &@this->_pending_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(88)] // size = 16, padding = 0
        public fixed ulong _watcher_queue[16 / 8]; // void*[2]

        public Span<nint> watcher_queue
        {
            get
            {
                fixed (uv_loop_t* @this = &this)
                {
                    var pointer = &@this->_watcher_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(104)] // size = 8, padding = 0
        public uv__io_t** watchers;

        [FieldOffset(112)] // size = 4, padding = 0
        public uint nwatchers;

        [FieldOffset(116)] // size = 4, padding = 0
        public uint nfds;

        [FieldOffset(120)] // size = 16, padding = 0
        public fixed ulong _wq[16 / 8]; // void*[2]

        public Span<nint> wq
        {
            get
            {
                fixed (uv_loop_t* @this = &this)
                {
                    var pointer = &@this->_wq[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(136)] // size = 40, padding = 0
        public uv_mutex_t wq_mutex;

        [FieldOffset(176)] // size = 128, padding = 0
        public uv_async_t wq_async;

        [FieldOffset(304)] // size = 56, padding = 0
        public uv_rwlock_t cloexec_lock;

        [FieldOffset(360)] // size = 8, padding = 0
        public uv_handle_t* closing_handles;

        [FieldOffset(368)] // size = 16, padding = 0
        public fixed ulong _process_handles[16 / 8]; // void*[2]

        public Span<nint> process_handles
        {
            get
            {
                fixed (uv_loop_t* @this = &this)
                {
                    var pointer = &@this->_process_handles[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(384)] // size = 16, padding = 0
        public fixed ulong _prepare_handles[16 / 8]; // void*[2]

        public Span<nint> prepare_handles
        {
            get
            {
                fixed (uv_loop_t* @this = &this)
                {
                    var pointer = &@this->_prepare_handles[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(400)] // size = 16, padding = 0
        public fixed ulong _check_handles[16 / 8]; // void*[2]

        public Span<nint> check_handles
        {
            get
            {
                fixed (uv_loop_t* @this = &this)
                {
                    var pointer = &@this->_check_handles[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(416)] // size = 16, padding = 0
        public fixed ulong _idle_handles[16 / 8]; // void*[2]

        public Span<nint> idle_handles
        {
            get
            {
                fixed (uv_loop_t* @this = &this)
                {
                    var pointer = &@this->_idle_handles[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(432)] // size = 16, padding = 0
        public fixed ulong _async_handles[16 / 8]; // void*[2]

        public Span<nint> async_handles
        {
            get
            {
                fixed (uv_loop_t* @this = &this)
                {
                    var pointer = &@this->_async_handles[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(448)] // size = 8, padding = 0
        public FnPtr_UV_Void async_unused;

        [FieldOffset(456)] // size = 56, padding = 0
        public uv__io_t async_io_watcher;

        [FieldOffset(512)] // size = 4, padding = 4
        public int async_wfd;

        [FieldOffset(520)] // size = 16, padding = 0
        public uv_loop_t_timer_heap timer_heap;

        [FieldOffset(536)] // size = 8, padding = 0
        public ulong timer_counter;

        [FieldOffset(544)] // size = 8, padding = 0
        public ulong time;

        [FieldOffset(552)] // size = 8, padding = 0
        public fixed uint _signal_pipefd[8 / 4]; // int[2]

        public Span<int> signal_pipefd
        {
            get
            {
                fixed (uv_loop_t* @this = &this)
                {
                    var pointer = &@this->_signal_pipefd[0];
                    var span = new Span<int>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(560)] // size = 56, padding = 0
        public uv__io_t signal_io_watcher;

        [FieldOffset(616)] // size = 152, padding = 0
        public uv_signal_t child_watcher;

        [FieldOffset(768)] // size = 4, padding = 4
        public int emfile_fd;

        [FieldOffset(776)] // size = 56, padding = 0
        public uv__io_t inotify_read_watcher;

        [FieldOffset(832)] // size = 8, padding = 0
        public void* inotify_watchers;

        [FieldOffset(840)] // size = 4, padding = 4
        public int inotify_fd;

        // Union @ uv.h:1811:3
        [StructLayout(LayoutKind.Explicit, Size = 8, Pack = 8)]
        public struct uv_loop_t_active_reqs
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public void* unused;

            [FieldOffset(0)] // size = 4, padding = 4
            public uint count;
        }

        // Struct @ uv.h:1819:3
        [StructLayout(LayoutKind.Explicit, Size = 16, Pack = 8)]
        public struct uv_loop_t_timer_heap
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public void* min;

            [FieldOffset(8)] // size = 4, padding = 4
            public uint nelts;
        }
    }

    // Struct @ uv.h:214:28
    [StructLayout(LayoutKind.Explicit, Size = 96, Pack = 8)]
    public struct uv_handle_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public void* data;

        [FieldOffset(8)] // size = 8, padding = 0
        public uv_loop_t* loop;

        [FieldOffset(16)] // size = 4, padding = 4
        public uv_handle_type type;

        [FieldOffset(24)] // size = 8, padding = 0
        public uv_close_cb close_cb;

        [FieldOffset(32)] // size = 16, padding = 0
        public fixed ulong _handle_queue[16 / 8]; // void*[2]

        public Span<nint> handle_queue
        {
            get
            {
                fixed (uv_handle_t* @this = &this)
                {
                    var pointer = &@this->_handle_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(48)] // size = 32, padding = 0
        public uv_handle_t_u u;

        [FieldOffset(80)] // size = 8, padding = 0
        public uv_handle_t* next_closing;

        [FieldOffset(88)] // size = 4, padding = 4
        public uint flags;

        // Union @ uv.h:449:3
        [StructLayout(LayoutKind.Explicit, Size = 32, Pack = 8)]
        public struct uv_handle_t_u
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public int fd;

            [FieldOffset(0)] // size = 32, padding = 0
            public fixed ulong _reserved[32 / 8]; // void*[4]

            public Span<nint> reserved
            {
                get
                {
                    fixed (uv_handle_t_u* @this = &this)
                    {
                        var pointer = &@this->_reserved[0];
                        var span = new Span<nint>(pointer, 4);
                        return span;
                    }
                }
            }
        }
    }

    // Struct @ uv.h:236:30
    [StructLayout(LayoutKind.Explicit, Size = 80, Pack = 8)]
    public struct uv_shutdown_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public void* data;

        [FieldOffset(8)] // size = 4, padding = 4
        public uv_req_type type;

        [FieldOffset(16)] // size = 48, padding = 0
        public fixed ulong _reserved[48 / 8]; // void*[6]

        public Span<nint> reserved
        {
            get
            {
                fixed (uv_shutdown_t* @this = &this)
                {
                    var pointer = &@this->_reserved[0];
                    var span = new Span<nint>(pointer, 6);
                    return span;
                }
            }
        }

        [FieldOffset(64)] // size = 8, padding = 0
        public uv_stream_t* handle;

        [FieldOffset(72)] // size = 8, padding = 0
        public uv_shutdown_cb cb;
    }

    // Struct @ uv.h:216:28
    [StructLayout(LayoutKind.Explicit, Size = 248, Pack = 8)]
    public struct uv_stream_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public void* data;

        [FieldOffset(8)] // size = 8, padding = 0
        public uv_loop_t* loop;

        [FieldOffset(16)] // size = 4, padding = 4
        public uv_handle_type type;

        [FieldOffset(24)] // size = 8, padding = 0
        public uv_close_cb close_cb;

        [FieldOffset(32)] // size = 16, padding = 0
        public fixed ulong _handle_queue[16 / 8]; // void*[2]

        public Span<nint> handle_queue
        {
            get
            {
                fixed (uv_stream_t* @this = &this)
                {
                    var pointer = &@this->_handle_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(48)] // size = 32, padding = 0
        public uv_stream_t_u u;

        [FieldOffset(80)] // size = 8, padding = 0
        public uv_handle_t* next_closing;

        [FieldOffset(88)] // size = 4, padding = 4
        public uint flags;

        [FieldOffset(96)] // size = 8, padding = 0
        public ulong write_queue_size;

        [FieldOffset(104)] // size = 8, padding = 0
        public uv_alloc_cb alloc_cb;

        [FieldOffset(112)] // size = 8, padding = 0
        public uv_read_cb read_cb;

        [FieldOffset(120)] // size = 8, padding = 0
        public uv_connect_t* connect_req;

        [FieldOffset(128)] // size = 8, padding = 0
        public uv_shutdown_t* shutdown_req;

        [FieldOffset(136)] // size = 56, padding = 0
        public uv__io_t io_watcher;

        [FieldOffset(192)] // size = 16, padding = 0
        public fixed ulong _write_queue[16 / 8]; // void*[2]

        public Span<nint> write_queue
        {
            get
            {
                fixed (uv_stream_t* @this = &this)
                {
                    var pointer = &@this->_write_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(208)] // size = 16, padding = 0
        public fixed ulong _write_completed_queue[16 / 8]; // void*[2]

        public Span<nint> write_completed_queue
        {
            get
            {
                fixed (uv_stream_t* @this = &this)
                {
                    var pointer = &@this->_write_completed_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(224)] // size = 8, padding = 0
        public uv_connection_cb connection_cb;

        [FieldOffset(232)] // size = 4, padding = 0
        public int delayed_error;

        [FieldOffset(236)] // size = 4, padding = 0
        public int accepted_fd;

        [FieldOffset(240)] // size = 8, padding = 0
        public void* queued_fds;

        // Union @ uv.h:505:3
        [StructLayout(LayoutKind.Explicit, Size = 32, Pack = 8)]
        public struct uv_stream_t_u
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public int fd;

            [FieldOffset(0)] // size = 32, padding = 0
            public fixed ulong _reserved[32 / 8]; // void*[4]

            public Span<nint> reserved
            {
                get
                {
                    fixed (uv_stream_t_u* @this = &this)
                    {
                        var pointer = &@this->_reserved[0];
                        var span = new Span<nint>(pointer, 4);
                        return span;
                    }
                }
            }
        }
    }

    // Struct @ uv.h:233:25
    [StructLayout(LayoutKind.Explicit, Size = 64, Pack = 8)]
    public struct uv_req_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public void* data;

        [FieldOffset(8)] // size = 4, padding = 4
        public uv_req_type type;

        [FieldOffset(16)] // size = 48, padding = 0
        public fixed ulong _reserved[48 / 8]; // void*[6]

        public Span<nint> reserved
        {
            get
            {
                fixed (uv_req_t* @this = &this)
                {
                    var pointer = &@this->_reserved[0];
                    var span = new Span<nint>(pointer, 6);
                    return span;
                }
            }
        }
    }

    // Struct @ unix.h:124:3 (uv/unix.h)
    [StructLayout(LayoutKind.Explicit, Size = 16, Pack = 8)]
    public struct uv_buf_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public CString @base;

        [FieldOffset(8)] // size = 8, padding = 0
        public ulong len;
    }

    // Struct @ uv.h:237:27
    [StructLayout(LayoutKind.Explicit, Size = 192, Pack = 8)]
    public struct uv_write_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public void* data;

        [FieldOffset(8)] // size = 4, padding = 4
        public uv_req_type type;

        [FieldOffset(16)] // size = 48, padding = 0
        public fixed ulong _reserved[48 / 8]; // void*[6]

        public Span<nint> reserved
        {
            get
            {
                fixed (uv_write_t* @this = &this)
                {
                    var pointer = &@this->_reserved[0];
                    var span = new Span<nint>(pointer, 6);
                    return span;
                }
            }
        }

        [FieldOffset(64)] // size = 8, padding = 0
        public uv_write_cb cb;

        [FieldOffset(72)] // size = 8, padding = 0
        public uv_stream_t* send_handle;

        [FieldOffset(80)] // size = 8, padding = 0
        public uv_stream_t* handle;

        [FieldOffset(88)] // size = 16, padding = 0
        public fixed ulong _queue[16 / 8]; // void*[2]

        public Span<nint> queue
        {
            get
            {
                fixed (uv_write_t* @this = &this)
                {
                    var pointer = &@this->_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(104)] // size = 4, padding = 4
        public uint write_index;

        [FieldOffset(112)] // size = 8, padding = 0
        public uv_buf_t* bufs;

        [FieldOffset(120)] // size = 4, padding = 0
        public uint nbufs;

        [FieldOffset(124)] // size = 4, padding = 0
        public int error;

        [FieldOffset(128)] // size = 64, padding = 0
        public fixed ulong _bufsml[64 / 8]; // uv_buf_t[4]

        public Span<uv_buf_t> bufsml
        {
            get
            {
                fixed (uv_write_t* @this = &this)
                {
                    var pointer = &@this->_bufsml[0];
                    var span = new Span<uv_buf_t>(pointer, 4);
                    return span;
                }
            }
        }
    }

    // Struct @ uv.h:217:25
    [StructLayout(LayoutKind.Explicit, Size = 248, Pack = 8)]
    public struct uv_tcp_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public void* data;

        [FieldOffset(8)] // size = 8, padding = 0
        public uv_loop_t* loop;

        [FieldOffset(16)] // size = 4, padding = 4
        public uv_handle_type type;

        [FieldOffset(24)] // size = 8, padding = 0
        public uv_close_cb close_cb;

        [FieldOffset(32)] // size = 16, padding = 0
        public fixed ulong _handle_queue[16 / 8]; // void*[2]

        public Span<nint> handle_queue
        {
            get
            {
                fixed (uv_tcp_t* @this = &this)
                {
                    var pointer = &@this->_handle_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(48)] // size = 32, padding = 0
        public uv_tcp_t_u u;

        [FieldOffset(80)] // size = 8, padding = 0
        public uv_handle_t* next_closing;

        [FieldOffset(88)] // size = 4, padding = 4
        public uint flags;

        [FieldOffset(96)] // size = 8, padding = 0
        public ulong write_queue_size;

        [FieldOffset(104)] // size = 8, padding = 0
        public uv_alloc_cb alloc_cb;

        [FieldOffset(112)] // size = 8, padding = 0
        public uv_read_cb read_cb;

        [FieldOffset(120)] // size = 8, padding = 0
        public uv_connect_t* connect_req;

        [FieldOffset(128)] // size = 8, padding = 0
        public uv_shutdown_t* shutdown_req;

        [FieldOffset(136)] // size = 56, padding = 0
        public uv__io_t io_watcher;

        [FieldOffset(192)] // size = 16, padding = 0
        public fixed ulong _write_queue[16 / 8]; // void*[2]

        public Span<nint> write_queue
        {
            get
            {
                fixed (uv_tcp_t* @this = &this)
                {
                    var pointer = &@this->_write_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(208)] // size = 16, padding = 0
        public fixed ulong _write_completed_queue[16 / 8]; // void*[2]

        public Span<nint> write_completed_queue
        {
            get
            {
                fixed (uv_tcp_t* @this = &this)
                {
                    var pointer = &@this->_write_completed_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(224)] // size = 8, padding = 0
        public uv_connection_cb connection_cb;

        [FieldOffset(232)] // size = 4, padding = 0
        public int delayed_error;

        [FieldOffset(236)] // size = 4, padding = 0
        public int accepted_fd;

        [FieldOffset(240)] // size = 8, padding = 0
        public void* queued_fds;

        // Union @ uv.h:562:3
        [StructLayout(LayoutKind.Explicit, Size = 32, Pack = 8)]
        public struct uv_tcp_t_u
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public int fd;

            [FieldOffset(0)] // size = 32, padding = 0
            public fixed ulong _reserved[32 / 8]; // void*[4]

            public Span<nint> reserved
            {
                get
                {
                    fixed (uv_tcp_t_u* @this = &this)
                    {
                        var pointer = &@this->_reserved[0];
                        var span = new Span<nint>(pointer, 4);
                        return span;
                    }
                }
            }
        }
    }

    // Struct @ socket.h:178:8 (/usr/include/x86_64-linux-gnu/bits/socket.h)
    [StructLayout(LayoutKind.Explicit, Size = 16, Pack = 2)]
    public struct sockaddr
    {
        [FieldOffset(0)] // size = 2, padding = 0
        public sa_family_t sa_family;

        [FieldOffset(2)] // size = 14, padding = 0
        public fixed byte _sa_data[14 / 1]; // char[14]

        public string sa_data
        {
            get
            {
                fixed (sockaddr* @this = &this)
                {
                    var pointer = &@this->_sa_data[0];
                    var cString = new CString(pointer);
                    return uv.CStrings.String(cString);
                }
            }
        }
    }

    // Struct @ uv.h:238:29
    [StructLayout(LayoutKind.Explicit, Size = 96, Pack = 8)]
    public struct uv_connect_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public void* data;

        [FieldOffset(8)] // size = 4, padding = 4
        public uv_req_type type;

        [FieldOffset(16)] // size = 48, padding = 0
        public fixed ulong _reserved[48 / 8]; // void*[6]

        public Span<nint> reserved
        {
            get
            {
                fixed (uv_connect_t* @this = &this)
                {
                    var pointer = &@this->_reserved[0];
                    var span = new Span<nint>(pointer, 6);
                    return span;
                }
            }
        }

        [FieldOffset(64)] // size = 8, padding = 0
        public uv_connect_cb cb;

        [FieldOffset(72)] // size = 8, padding = 0
        public uv_stream_t* handle;

        [FieldOffset(80)] // size = 16, padding = 0
        public fixed ulong _queue[16 / 8]; // void*[2]

        public Span<nint> queue
        {
            get
            {
                fixed (uv_connect_t* @this = &this)
                {
                    var pointer = &@this->_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }
    }

    // Struct @ uv.h:218:25
    [StructLayout(LayoutKind.Explicit, Size = 216, Pack = 8)]
    public struct uv_udp_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public void* data;

        [FieldOffset(8)] // size = 8, padding = 0
        public uv_loop_t* loop;

        [FieldOffset(16)] // size = 4, padding = 4
        public uv_handle_type type;

        [FieldOffset(24)] // size = 8, padding = 0
        public uv_close_cb close_cb;

        [FieldOffset(32)] // size = 16, padding = 0
        public fixed ulong _handle_queue[16 / 8]; // void*[2]

        public Span<nint> handle_queue
        {
            get
            {
                fixed (uv_udp_t* @this = &this)
                {
                    var pointer = &@this->_handle_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(48)] // size = 32, padding = 0
        public uv_udp_t_u u;

        [FieldOffset(80)] // size = 8, padding = 0
        public uv_handle_t* next_closing;

        [FieldOffset(88)] // size = 4, padding = 4
        public uint flags;

        [FieldOffset(96)] // size = 8, padding = 0
        public ulong send_queue_size;

        [FieldOffset(104)] // size = 8, padding = 0
        public ulong send_queue_count;

        [FieldOffset(112)] // size = 8, padding = 0
        public uv_alloc_cb alloc_cb;

        [FieldOffset(120)] // size = 8, padding = 0
        public uv_udp_recv_cb recv_cb;

        [FieldOffset(128)] // size = 56, padding = 0
        public uv__io_t io_watcher;

        [FieldOffset(184)] // size = 16, padding = 0
        public fixed ulong _write_queue[16 / 8]; // void*[2]

        public Span<nint> write_queue
        {
            get
            {
                fixed (uv_udp_t* @this = &this)
                {
                    var pointer = &@this->_write_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(200)] // size = 16, padding = 0
        public fixed ulong _write_completed_queue[16 / 8]; // void*[2]

        public Span<nint> write_completed_queue
        {
            get
            {
                fixed (uv_udp_t* @this = &this)
                {
                    var pointer = &@this->_write_completed_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        // Union @ uv.h:660:3
        [StructLayout(LayoutKind.Explicit, Size = 32, Pack = 8)]
        public struct uv_udp_t_u
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public int fd;

            [FieldOffset(0)] // size = 32, padding = 0
            public fixed ulong _reserved[32 / 8]; // void*[4]

            public Span<nint> reserved
            {
                get
                {
                    fixed (uv_udp_t_u* @this = &this)
                    {
                        var pointer = &@this->_reserved[0];
                        var span = new Span<nint>(pointer, 4);
                        return span;
                    }
                }
            }
        }
    }

    // Struct @ uv.h:239:30
    [StructLayout(LayoutKind.Explicit, Size = 320, Pack = 8)]
    public struct uv_udp_send_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public void* data;

        [FieldOffset(8)] // size = 4, padding = 4
        public uv_req_type type;

        [FieldOffset(16)] // size = 48, padding = 0
        public fixed ulong _reserved[48 / 8]; // void*[6]

        public Span<nint> reserved
        {
            get
            {
                fixed (uv_udp_send_t* @this = &this)
                {
                    var pointer = &@this->_reserved[0];
                    var span = new Span<nint>(pointer, 6);
                    return span;
                }
            }
        }

        [FieldOffset(64)] // size = 8, padding = 0
        public uv_udp_t* handle;

        [FieldOffset(72)] // size = 8, padding = 0
        public uv_udp_send_cb cb;

        [FieldOffset(80)] // size = 16, padding = 0
        public fixed ulong _queue[16 / 8]; // void*[2]

        public Span<nint> queue
        {
            get
            {
                fixed (uv_udp_send_t* @this = &this)
                {
                    var pointer = &@this->_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(96)] // size = 128, padding = 0
        public sockaddr_storage addr;

        [FieldOffset(224)] // size = 4, padding = 4
        public uint nbufs;

        [FieldOffset(232)] // size = 8, padding = 0
        public uv_buf_t* bufs;

        [FieldOffset(240)] // size = 8, padding = 0
        public long status;

        [FieldOffset(248)] // size = 8, padding = 0
        public uv_udp_send_cb send_cb;

        [FieldOffset(256)] // size = 64, padding = 0
        public fixed ulong _bufsml[64 / 8]; // uv_buf_t[4]

        public Span<uv_buf_t> bufsml
        {
            get
            {
                fixed (uv_udp_send_t* @this = &this)
                {
                    var pointer = &@this->_bufsml[0];
                    var span = new Span<uv_buf_t>(pointer, 4);
                    return span;
                }
            }
        }
    }

    // Struct @ uv.h:220:25
    [StructLayout(LayoutKind.Explicit, Size = 312, Pack = 8)]
    public struct uv_tty_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public void* data;

        [FieldOffset(8)] // size = 8, padding = 0
        public uv_loop_t* loop;

        [FieldOffset(16)] // size = 4, padding = 4
        public uv_handle_type type;

        [FieldOffset(24)] // size = 8, padding = 0
        public uv_close_cb close_cb;

        [FieldOffset(32)] // size = 16, padding = 0
        public fixed ulong _handle_queue[16 / 8]; // void*[2]

        public Span<nint> handle_queue
        {
            get
            {
                fixed (uv_tty_t* @this = &this)
                {
                    var pointer = &@this->_handle_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(48)] // size = 32, padding = 0
        public uv_tty_t_u u;

        [FieldOffset(80)] // size = 8, padding = 0
        public uv_handle_t* next_closing;

        [FieldOffset(88)] // size = 4, padding = 4
        public uint flags;

        [FieldOffset(96)] // size = 8, padding = 0
        public ulong write_queue_size;

        [FieldOffset(104)] // size = 8, padding = 0
        public uv_alloc_cb alloc_cb;

        [FieldOffset(112)] // size = 8, padding = 0
        public uv_read_cb read_cb;

        [FieldOffset(120)] // size = 8, padding = 0
        public uv_connect_t* connect_req;

        [FieldOffset(128)] // size = 8, padding = 0
        public uv_shutdown_t* shutdown_req;

        [FieldOffset(136)] // size = 56, padding = 0
        public uv__io_t io_watcher;

        [FieldOffset(192)] // size = 16, padding = 0
        public fixed ulong _write_queue[16 / 8]; // void*[2]

        public Span<nint> write_queue
        {
            get
            {
                fixed (uv_tty_t* @this = &this)
                {
                    var pointer = &@this->_write_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(208)] // size = 16, padding = 0
        public fixed ulong _write_completed_queue[16 / 8]; // void*[2]

        public Span<nint> write_completed_queue
        {
            get
            {
                fixed (uv_tty_t* @this = &this)
                {
                    var pointer = &@this->_write_completed_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(224)] // size = 8, padding = 0
        public uv_connection_cb connection_cb;

        [FieldOffset(232)] // size = 4, padding = 0
        public int delayed_error;

        [FieldOffset(236)] // size = 4, padding = 0
        public int accepted_fd;

        [FieldOffset(240)] // size = 8, padding = 0
        public void* queued_fds;

        [FieldOffset(248)] // size = 60, padding = 0
        public termios orig_termios;

        [FieldOffset(308)] // size = 4, padding = 0
        public int mode;

        // Union @ uv.h:736:3
        [StructLayout(LayoutKind.Explicit, Size = 32, Pack = 8)]
        public struct uv_tty_t_u
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public int fd;

            [FieldOffset(0)] // size = 32, padding = 0
            public fixed ulong _reserved[32 / 8]; // void*[4]

            public Span<nint> reserved
            {
                get
                {
                    fixed (uv_tty_t_u* @this = &this)
                    {
                        var pointer = &@this->_reserved[0];
                        var span = new Span<nint>(pointer, 4);
                        return span;
                    }
                }
            }
        }
    }

    // Struct @ uv.h:219:26
    [StructLayout(LayoutKind.Explicit, Size = 264, Pack = 8)]
    public struct uv_pipe_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public void* data;

        [FieldOffset(8)] // size = 8, padding = 0
        public uv_loop_t* loop;

        [FieldOffset(16)] // size = 4, padding = 4
        public uv_handle_type type;

        [FieldOffset(24)] // size = 8, padding = 0
        public uv_close_cb close_cb;

        [FieldOffset(32)] // size = 16, padding = 0
        public fixed ulong _handle_queue[16 / 8]; // void*[2]

        public Span<nint> handle_queue
        {
            get
            {
                fixed (uv_pipe_t* @this = &this)
                {
                    var pointer = &@this->_handle_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(48)] // size = 32, padding = 0
        public uv_pipe_t_u u;

        [FieldOffset(80)] // size = 8, padding = 0
        public uv_handle_t* next_closing;

        [FieldOffset(88)] // size = 4, padding = 4
        public uint flags;

        [FieldOffset(96)] // size = 8, padding = 0
        public ulong write_queue_size;

        [FieldOffset(104)] // size = 8, padding = 0
        public uv_alloc_cb alloc_cb;

        [FieldOffset(112)] // size = 8, padding = 0
        public uv_read_cb read_cb;

        [FieldOffset(120)] // size = 8, padding = 0
        public uv_connect_t* connect_req;

        [FieldOffset(128)] // size = 8, padding = 0
        public uv_shutdown_t* shutdown_req;

        [FieldOffset(136)] // size = 56, padding = 0
        public uv__io_t io_watcher;

        [FieldOffset(192)] // size = 16, padding = 0
        public fixed ulong _write_queue[16 / 8]; // void*[2]

        public Span<nint> write_queue
        {
            get
            {
                fixed (uv_pipe_t* @this = &this)
                {
                    var pointer = &@this->_write_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(208)] // size = 16, padding = 0
        public fixed ulong _write_completed_queue[16 / 8]; // void*[2]

        public Span<nint> write_completed_queue
        {
            get
            {
                fixed (uv_pipe_t* @this = &this)
                {
                    var pointer = &@this->_write_completed_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(224)] // size = 8, padding = 0
        public uv_connection_cb connection_cb;

        [FieldOffset(232)] // size = 4, padding = 0
        public int delayed_error;

        [FieldOffset(236)] // size = 4, padding = 0
        public int accepted_fd;

        [FieldOffset(240)] // size = 8, padding = 0
        public void* queued_fds;

        [FieldOffset(248)] // size = 4, padding = 4
        public int ipc;

        [FieldOffset(256)] // size = 8, padding = 0
        public CString pipe_fname;

        // Union @ uv.h:789:3
        [StructLayout(LayoutKind.Explicit, Size = 32, Pack = 8)]
        public struct uv_pipe_t_u
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public int fd;

            [FieldOffset(0)] // size = 32, padding = 0
            public fixed ulong _reserved[32 / 8]; // void*[4]

            public Span<nint> reserved
            {
                get
                {
                    fixed (uv_pipe_t_u* @this = &this)
                    {
                        var pointer = &@this->_reserved[0];
                        var span = new Span<nint>(pointer, 4);
                        return span;
                    }
                }
            }
        }
    }

    // Struct @ uv.h:221:26
    [StructLayout(LayoutKind.Explicit, Size = 160, Pack = 8)]
    public struct uv_poll_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public void* data;

        [FieldOffset(8)] // size = 8, padding = 0
        public uv_loop_t* loop;

        [FieldOffset(16)] // size = 4, padding = 4
        public uv_handle_type type;

        [FieldOffset(24)] // size = 8, padding = 0
        public uv_close_cb close_cb;

        [FieldOffset(32)] // size = 16, padding = 0
        public fixed ulong _handle_queue[16 / 8]; // void*[2]

        public Span<nint> handle_queue
        {
            get
            {
                fixed (uv_poll_t* @this = &this)
                {
                    var pointer = &@this->_handle_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(48)] // size = 32, padding = 0
        public uv_poll_t_u u;

        [FieldOffset(80)] // size = 8, padding = 0
        public uv_handle_t* next_closing;

        [FieldOffset(88)] // size = 4, padding = 4
        public uint flags;

        [FieldOffset(96)] // size = 8, padding = 0
        public uv_poll_cb poll_cb;

        [FieldOffset(104)] // size = 56, padding = 0
        public uv__io_t io_watcher;

        // Union @ uv.h:815:3
        [StructLayout(LayoutKind.Explicit, Size = 32, Pack = 8)]
        public struct uv_poll_t_u
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public int fd;

            [FieldOffset(0)] // size = 32, padding = 0
            public fixed ulong _reserved[32 / 8]; // void*[4]

            public Span<nint> reserved
            {
                get
                {
                    fixed (uv_poll_t_u* @this = &this)
                    {
                        var pointer = &@this->_reserved[0];
                        var span = new Span<nint>(pointer, 4);
                        return span;
                    }
                }
            }
        }
    }

    // Struct @ uv.h:223:29
    [StructLayout(LayoutKind.Explicit, Size = 120, Pack = 8)]
    public struct uv_prepare_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public void* data;

        [FieldOffset(8)] // size = 8, padding = 0
        public uv_loop_t* loop;

        [FieldOffset(16)] // size = 4, padding = 4
        public uv_handle_type type;

        [FieldOffset(24)] // size = 8, padding = 0
        public uv_close_cb close_cb;

        [FieldOffset(32)] // size = 16, padding = 0
        public fixed ulong _handle_queue[16 / 8]; // void*[2]

        public Span<nint> handle_queue
        {
            get
            {
                fixed (uv_prepare_t* @this = &this)
                {
                    var pointer = &@this->_handle_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(48)] // size = 32, padding = 0
        public uv_prepare_t_u u;

        [FieldOffset(80)] // size = 8, padding = 0
        public uv_handle_t* next_closing;

        [FieldOffset(88)] // size = 4, padding = 4
        public uint flags;

        [FieldOffset(96)] // size = 8, padding = 0
        public uv_prepare_cb prepare_cb;

        [FieldOffset(104)] // size = 16, padding = 0
        public fixed ulong _queue[16 / 8]; // void*[2]

        public Span<nint> queue
        {
            get
            {
                fixed (uv_prepare_t* @this = &this)
                {
                    var pointer = &@this->_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        // Union @ uv.h:836:3
        [StructLayout(LayoutKind.Explicit, Size = 32, Pack = 8)]
        public struct uv_prepare_t_u
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public int fd;

            [FieldOffset(0)] // size = 32, padding = 0
            public fixed ulong _reserved[32 / 8]; // void*[4]

            public Span<nint> reserved
            {
                get
                {
                    fixed (uv_prepare_t_u* @this = &this)
                    {
                        var pointer = &@this->_reserved[0];
                        var span = new Span<nint>(pointer, 4);
                        return span;
                    }
                }
            }
        }
    }

    // Struct @ uv.h:224:27
    [StructLayout(LayoutKind.Explicit, Size = 120, Pack = 8)]
    public struct uv_check_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public void* data;

        [FieldOffset(8)] // size = 8, padding = 0
        public uv_loop_t* loop;

        [FieldOffset(16)] // size = 4, padding = 4
        public uv_handle_type type;

        [FieldOffset(24)] // size = 8, padding = 0
        public uv_close_cb close_cb;

        [FieldOffset(32)] // size = 16, padding = 0
        public fixed ulong _handle_queue[16 / 8]; // void*[2]

        public Span<nint> handle_queue
        {
            get
            {
                fixed (uv_check_t* @this = &this)
                {
                    var pointer = &@this->_handle_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(48)] // size = 32, padding = 0
        public uv_check_t_u u;

        [FieldOffset(80)] // size = 8, padding = 0
        public uv_handle_t* next_closing;

        [FieldOffset(88)] // size = 4, padding = 4
        public uint flags;

        [FieldOffset(96)] // size = 8, padding = 0
        public uv_check_cb check_cb;

        [FieldOffset(104)] // size = 16, padding = 0
        public fixed ulong _queue[16 / 8]; // void*[2]

        public Span<nint> queue
        {
            get
            {
                fixed (uv_check_t* @this = &this)
                {
                    var pointer = &@this->_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        // Union @ uv.h:846:3
        [StructLayout(LayoutKind.Explicit, Size = 32, Pack = 8)]
        public struct uv_check_t_u
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public int fd;

            [FieldOffset(0)] // size = 32, padding = 0
            public fixed ulong _reserved[32 / 8]; // void*[4]

            public Span<nint> reserved
            {
                get
                {
                    fixed (uv_check_t_u* @this = &this)
                    {
                        var pointer = &@this->_reserved[0];
                        var span = new Span<nint>(pointer, 4);
                        return span;
                    }
                }
            }
        }
    }

    // Struct @ uv.h:225:26
    [StructLayout(LayoutKind.Explicit, Size = 120, Pack = 8)]
    public struct uv_idle_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public void* data;

        [FieldOffset(8)] // size = 8, padding = 0
        public uv_loop_t* loop;

        [FieldOffset(16)] // size = 4, padding = 4
        public uv_handle_type type;

        [FieldOffset(24)] // size = 8, padding = 0
        public uv_close_cb close_cb;

        [FieldOffset(32)] // size = 16, padding = 0
        public fixed ulong _handle_queue[16 / 8]; // void*[2]

        public Span<nint> handle_queue
        {
            get
            {
                fixed (uv_idle_t* @this = &this)
                {
                    var pointer = &@this->_handle_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(48)] // size = 32, padding = 0
        public uv_idle_t_u u;

        [FieldOffset(80)] // size = 8, padding = 0
        public uv_handle_t* next_closing;

        [FieldOffset(88)] // size = 4, padding = 4
        public uint flags;

        [FieldOffset(96)] // size = 8, padding = 0
        public uv_idle_cb idle_cb;

        [FieldOffset(104)] // size = 16, padding = 0
        public fixed ulong _queue[16 / 8]; // void*[2]

        public Span<nint> queue
        {
            get
            {
                fixed (uv_idle_t* @this = &this)
                {
                    var pointer = &@this->_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        // Union @ uv.h:856:3
        [StructLayout(LayoutKind.Explicit, Size = 32, Pack = 8)]
        public struct uv_idle_t_u
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public int fd;

            [FieldOffset(0)] // size = 32, padding = 0
            public fixed ulong _reserved[32 / 8]; // void*[4]

            public Span<nint> reserved
            {
                get
                {
                    fixed (uv_idle_t_u* @this = &this)
                    {
                        var pointer = &@this->_reserved[0];
                        var span = new Span<nint>(pointer, 4);
                        return span;
                    }
                }
            }
        }
    }

    // Struct @ uv.h:226:27
    [StructLayout(LayoutKind.Explicit, Size = 128, Pack = 8)]
    public struct uv_async_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public void* data;

        [FieldOffset(8)] // size = 8, padding = 0
        public uv_loop_t* loop;

        [FieldOffset(16)] // size = 4, padding = 4
        public uv_handle_type type;

        [FieldOffset(24)] // size = 8, padding = 0
        public uv_close_cb close_cb;

        [FieldOffset(32)] // size = 16, padding = 0
        public fixed ulong _handle_queue[16 / 8]; // void*[2]

        public Span<nint> handle_queue
        {
            get
            {
                fixed (uv_async_t* @this = &this)
                {
                    var pointer = &@this->_handle_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(48)] // size = 32, padding = 0
        public uv_async_t_u u;

        [FieldOffset(80)] // size = 8, padding = 0
        public uv_handle_t* next_closing;

        [FieldOffset(88)] // size = 4, padding = 4
        public uint flags;

        [FieldOffset(96)] // size = 8, padding = 0
        public uv_async_cb async_cb;

        [FieldOffset(104)] // size = 16, padding = 0
        public fixed ulong _queue[16 / 8]; // void*[2]

        public Span<nint> queue
        {
            get
            {
                fixed (uv_async_t* @this = &this)
                {
                    var pointer = &@this->_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(120)] // size = 4, padding = 4
        public int pending;

        // Union @ uv.h:866:3
        [StructLayout(LayoutKind.Explicit, Size = 32, Pack = 8)]
        public struct uv_async_t_u
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public int fd;

            [FieldOffset(0)] // size = 32, padding = 0
            public fixed ulong _reserved[32 / 8]; // void*[4]

            public Span<nint> reserved
            {
                get
                {
                    fixed (uv_async_t_u* @this = &this)
                    {
                        var pointer = &@this->_reserved[0];
                        var span = new Span<nint>(pointer, 4);
                        return span;
                    }
                }
            }
        }
    }

    // Struct @ uv.h:222:27
    [StructLayout(LayoutKind.Explicit, Size = 152, Pack = 8)]
    public struct uv_timer_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public void* data;

        [FieldOffset(8)] // size = 8, padding = 0
        public uv_loop_t* loop;

        [FieldOffset(16)] // size = 4, padding = 4
        public uv_handle_type type;

        [FieldOffset(24)] // size = 8, padding = 0
        public uv_close_cb close_cb;

        [FieldOffset(32)] // size = 16, padding = 0
        public fixed ulong _handle_queue[16 / 8]; // void*[2]

        public Span<nint> handle_queue
        {
            get
            {
                fixed (uv_timer_t* @this = &this)
                {
                    var pointer = &@this->_handle_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(48)] // size = 32, padding = 0
        public uv_timer_t_u u;

        [FieldOffset(80)] // size = 8, padding = 0
        public uv_handle_t* next_closing;

        [FieldOffset(88)] // size = 4, padding = 4
        public uint flags;

        [FieldOffset(96)] // size = 8, padding = 0
        public uv_timer_cb timer_cb;

        [FieldOffset(104)] // size = 24, padding = 0
        public fixed ulong _heap_node[24 / 8]; // void*[3]

        public Span<nint> heap_node
        {
            get
            {
                fixed (uv_timer_t* @this = &this)
                {
                    var pointer = &@this->_heap_node[0];
                    var span = new Span<nint>(pointer, 3);
                    return span;
                }
            }
        }

        [FieldOffset(128)] // size = 8, padding = 0
        public ulong timeout;

        [FieldOffset(136)] // size = 8, padding = 0
        public ulong repeat;

        [FieldOffset(144)] // size = 8, padding = 0
        public ulong start_id;

        // Union @ uv.h:882:3
        [StructLayout(LayoutKind.Explicit, Size = 32, Pack = 8)]
        public struct uv_timer_t_u
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public int fd;

            [FieldOffset(0)] // size = 32, padding = 0
            public fixed ulong _reserved[32 / 8]; // void*[4]

            public Span<nint> reserved
            {
                get
                {
                    fixed (uv_timer_t_u* @this = &this)
                    {
                        var pointer = &@this->_reserved[0];
                        var span = new Span<nint>(pointer, 4);
                        return span;
                    }
                }
            }
        }
    }

    // Struct @ uv.h:234:33
    [StructLayout(LayoutKind.Explicit, Size = 160, Pack = 8)]
    public struct uv_getaddrinfo_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public void* data;

        [FieldOffset(8)] // size = 4, padding = 4
        public uv_req_type type;

        [FieldOffset(16)] // size = 48, padding = 0
        public fixed ulong _reserved[48 / 8]; // void*[6]

        public Span<nint> reserved
        {
            get
            {
                fixed (uv_getaddrinfo_t* @this = &this)
                {
                    var pointer = &@this->_reserved[0];
                    var span = new Span<nint>(pointer, 6);
                    return span;
                }
            }
        }

        [FieldOffset(64)] // size = 8, padding = 0
        public uv_loop_t* loop;

        [FieldOffset(72)] // size = 40, padding = 0
        public uv__work work_req;

        [FieldOffset(112)] // size = 8, padding = 0
        public uv_getaddrinfo_cb cb;

        [FieldOffset(120)] // size = 8, padding = 0
        public addrinfo* hints;

        [FieldOffset(128)] // size = 8, padding = 0
        public CString hostname;

        [FieldOffset(136)] // size = 8, padding = 0
        public CString service;

        [FieldOffset(144)] // size = 8, padding = 0
        public addrinfo* addrinfo;

        [FieldOffset(152)] // size = 4, padding = 4
        public int retcode;
    }

    // Struct @ netdb.h:565:8 (/usr/include/netdb.h)
    [StructLayout(LayoutKind.Explicit, Size = 48, Pack = 8)]
    public struct addrinfo
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public int ai_flags;

        [FieldOffset(4)] // size = 4, padding = 0
        public int ai_family;

        [FieldOffset(8)] // size = 4, padding = 0
        public int ai_socktype;

        [FieldOffset(12)] // size = 4, padding = 0
        public int ai_protocol;

        [FieldOffset(16)] // size = 4, padding = 4
        public socklen_t ai_addrlen;

        [FieldOffset(24)] // size = 8, padding = 0
        public sockaddr* ai_addr;

        [FieldOffset(32)] // size = 8, padding = 0
        public CString ai_canonname;

        [FieldOffset(40)] // size = 8, padding = 0
        public addrinfo* ai_next;
    }

    // Struct @ uv.h:235:33
    [StructLayout(LayoutKind.Explicit, Size = 1320, Pack = 8)]
    public struct uv_getnameinfo_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public void* data;

        [FieldOffset(8)] // size = 4, padding = 4
        public uv_req_type type;

        [FieldOffset(16)] // size = 48, padding = 0
        public fixed ulong _reserved[48 / 8]; // void*[6]

        public Span<nint> reserved
        {
            get
            {
                fixed (uv_getnameinfo_t* @this = &this)
                {
                    var pointer = &@this->_reserved[0];
                    var span = new Span<nint>(pointer, 6);
                    return span;
                }
            }
        }

        [FieldOffset(64)] // size = 8, padding = 0
        public uv_loop_t* loop;

        [FieldOffset(72)] // size = 40, padding = 0
        public uv__work work_req;

        [FieldOffset(112)] // size = 8, padding = 0
        public uv_getnameinfo_cb getnameinfo_cb;

        [FieldOffset(120)] // size = 128, padding = 0
        public sockaddr_storage storage;

        [FieldOffset(248)] // size = 4, padding = 0
        public int flags;

        [FieldOffset(252)] // size = 1025, padding = 0
        public fixed byte _host[1025 / 1]; // char[1025]

        public string host
        {
            get
            {
                fixed (uv_getnameinfo_t* @this = &this)
                {
                    var pointer = &@this->_host[0];
                    var cString = new CString(pointer);
                    return uv.CStrings.String(cString);
                }
            }
        }

        [FieldOffset(1277)] // size = 32, padding = 3
        public fixed byte _service[32 / 1]; // char[32]

        public string service
        {
            get
            {
                fixed (uv_getnameinfo_t* @this = &this)
                {
                    var pointer = &@this->_service[0];
                    var cString = new CString(pointer);
                    return uv.CStrings.String(cString);
                }
            }
        }

        [FieldOffset(1312)] // size = 4, padding = 4
        public int retcode;
    }

    // Struct @ uv.h:227:29
    [StructLayout(LayoutKind.Explicit, Size = 136, Pack = 8)]
    public struct uv_process_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public void* data;

        [FieldOffset(8)] // size = 8, padding = 0
        public uv_loop_t* loop;

        [FieldOffset(16)] // size = 4, padding = 4
        public uv_handle_type type;

        [FieldOffset(24)] // size = 8, padding = 0
        public uv_close_cb close_cb;

        [FieldOffset(32)] // size = 16, padding = 0
        public fixed ulong _handle_queue[16 / 8]; // void*[2]

        public Span<nint> handle_queue
        {
            get
            {
                fixed (uv_process_t* @this = &this)
                {
                    var pointer = &@this->_handle_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(48)] // size = 32, padding = 0
        public uv_process_t_u u;

        [FieldOffset(80)] // size = 8, padding = 0
        public uv_handle_t* next_closing;

        [FieldOffset(88)] // size = 4, padding = 4
        public uint flags;

        [FieldOffset(96)] // size = 8, padding = 0
        public uv_exit_cb exit_cb;

        [FieldOffset(104)] // size = 4, padding = 4
        public int pid;

        [FieldOffset(112)] // size = 16, padding = 0
        public fixed ulong _queue[16 / 8]; // void*[2]

        public Span<nint> queue
        {
            get
            {
                fixed (uv_process_t* @this = &this)
                {
                    var pointer = &@this->_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(128)] // size = 4, padding = 4
        public int status;

        // Union @ uv.h:1073:3
        [StructLayout(LayoutKind.Explicit, Size = 32, Pack = 8)]
        public struct uv_process_t_u
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public int fd;

            [FieldOffset(0)] // size = 32, padding = 0
            public fixed ulong _reserved[32 / 8]; // void*[4]

            public Span<nint> reserved
            {
                get
                {
                    fixed (uv_process_t_u* @this = &this)
                    {
                        var pointer = &@this->_reserved[0];
                        var span = new Span<nint>(pointer, 4);
                        return span;
                    }
                }
            }
        }
    }

    // Struct @ uv.h:1018:3
    [StructLayout(LayoutKind.Explicit, Size = 64, Pack = 8)]
    public struct uv_process_options_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public uv_exit_cb exit_cb;

        [FieldOffset(8)] // size = 8, padding = 0
        public CString file;

        [FieldOffset(16)] // size = 8, padding = 0
        public CString* args;

        [FieldOffset(24)] // size = 8, padding = 0
        public CString* env;

        [FieldOffset(32)] // size = 8, padding = 0
        public CString cwd;

        [FieldOffset(40)] // size = 4, padding = 0
        public uint flags;

        [FieldOffset(44)] // size = 4, padding = 0
        public int stdio_count;

        [FieldOffset(48)] // size = 8, padding = 0
        public uv_stdio_container_t* stdio;

        [FieldOffset(56)] // size = 4, padding = 0
        public uv_uid_t uid;

        [FieldOffset(60)] // size = 4, padding = 0
        public uv_gid_t gid;
    }

    // Struct @ uv.h:241:26
    [StructLayout(LayoutKind.Explicit, Size = 128, Pack = 8)]
    public struct uv_work_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public void* data;

        [FieldOffset(8)] // size = 4, padding = 4
        public uv_req_type type;

        [FieldOffset(16)] // size = 48, padding = 0
        public fixed ulong _reserved[48 / 8]; // void*[6]

        public Span<nint> reserved
        {
            get
            {
                fixed (uv_work_t* @this = &this)
                {
                    var pointer = &@this->_reserved[0];
                    var span = new Span<nint>(pointer, 6);
                    return span;
                }
            }
        }

        [FieldOffset(64)] // size = 8, padding = 0
        public uv_loop_t* loop;

        [FieldOffset(72)] // size = 8, padding = 0
        public uv_work_cb work_cb;

        [FieldOffset(80)] // size = 8, padding = 0
        public uv_after_work_cb after_work_cb;

        [FieldOffset(88)] // size = 40, padding = 0
        public uv__work work_req;
    }

    // Struct @ uv.h:1214:3
    [StructLayout(LayoutKind.Explicit, Size = 144, Pack = 8)]
    public struct uv_rusage_t
    {
        [FieldOffset(0)] // size = 16, padding = 0
        public uv_timeval_t ru_utime;

        [FieldOffset(16)] // size = 16, padding = 0
        public uv_timeval_t ru_stime;

        [FieldOffset(32)] // size = 8, padding = 0
        public ulong ru_maxrss;

        [FieldOffset(40)] // size = 8, padding = 0
        public ulong ru_ixrss;

        [FieldOffset(48)] // size = 8, padding = 0
        public ulong ru_idrss;

        [FieldOffset(56)] // size = 8, padding = 0
        public ulong ru_isrss;

        [FieldOffset(64)] // size = 8, padding = 0
        public ulong ru_minflt;

        [FieldOffset(72)] // size = 8, padding = 0
        public ulong ru_majflt;

        [FieldOffset(80)] // size = 8, padding = 0
        public ulong ru_nswap;

        [FieldOffset(88)] // size = 8, padding = 0
        public ulong ru_inblock;

        [FieldOffset(96)] // size = 8, padding = 0
        public ulong ru_oublock;

        [FieldOffset(104)] // size = 8, padding = 0
        public ulong ru_msgsnd;

        [FieldOffset(112)] // size = 8, padding = 0
        public ulong ru_msgrcv;

        [FieldOffset(120)] // size = 8, padding = 0
        public ulong ru_nsignals;

        [FieldOffset(128)] // size = 8, padding = 0
        public ulong ru_nvcsw;

        [FieldOffset(136)] // size = 8, padding = 0
        public ulong ru_nivcsw;
    }

    // Struct @ uv.h:249:28
    [StructLayout(LayoutKind.Explicit, Size = 40, Pack = 8)]
    public struct uv_passwd_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public CString username;

        [FieldOffset(8)] // size = 8, padding = 0
        public long uid;

        [FieldOffset(16)] // size = 8, padding = 0
        public long gid;

        [FieldOffset(24)] // size = 8, padding = 0
        public CString shell;

        [FieldOffset(32)] // size = 8, padding = 0
        public CString homedir;
    }

    // Struct @ uv.h:246:30
    [StructLayout(LayoutKind.Explicit, Size = 56, Pack = 8)]
    public struct uv_cpu_info_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public CString model;

        [FieldOffset(8)] // size = 4, padding = 4
        public int speed;

        [FieldOffset(16)] // size = 40, padding = 0
        public uv_cpu_times_s cpu_times;
    }

    // Struct @ uv.h:247:39
    [StructLayout(LayoutKind.Explicit, Size = 80, Pack = 8)]
    public struct uv_interface_address_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public CString name;

        [FieldOffset(8)] // size = 6, padding = 2
        public fixed byte _phys_addr[6 / 1]; // char[6]

        public string phys_addr
        {
            get
            {
                fixed (uv_interface_address_t* @this = &this)
                {
                    var pointer = &@this->_phys_addr[0];
                    var cString = new CString(pointer);
                    return uv.CStrings.String(cString);
                }
            }
        }

        [FieldOffset(16)] // size = 4, padding = 0
        public int is_internal;

        [FieldOffset(20)] // size = 28, padding = 0
        public uv_interface_address_t_address address;

        [FieldOffset(48)] // size = 28, padding = 4
        public uv_interface_address_t_netmask netmask;

        // Union @ uv.h:1124:3
        [StructLayout(LayoutKind.Explicit, Size = 28, Pack = 4)]
        public struct uv_interface_address_t_address
        {
            [FieldOffset(0)] // size = 16, padding = 0
            public sockaddr_in address4;

            [FieldOffset(0)] // size = 28, padding = 0
            public sockaddr_in6 address6;
        }

        // Union @ uv.h:1128:3
        [StructLayout(LayoutKind.Explicit, Size = 28, Pack = 4)]
        public struct uv_interface_address_t_netmask
        {
            [FieldOffset(0)] // size = 16, padding = 0
            public sockaddr_in netmask4;

            [FieldOffset(0)] // size = 28, padding = 0
            public sockaddr_in6 netmask6;
        }
    }

    // Struct @ uv.h:245:30
    [StructLayout(LayoutKind.Explicit, Size = 16, Pack = 8)]
    public struct uv_env_item_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public CString name;

        [FieldOffset(8)] // size = 8, padding = 0
        public CString value;
    }

    // Struct @ uv.h:250:29
    [StructLayout(LayoutKind.Explicit, Size = 1024, Pack = 1)]
    public struct uv_utsname_t
    {
        [FieldOffset(0)] // size = 256, padding = 0
        public fixed byte _sysname[256 / 1]; // char[256]

        public string sysname
        {
            get
            {
                fixed (uv_utsname_t* @this = &this)
                {
                    var pointer = &@this->_sysname[0];
                    var cString = new CString(pointer);
                    return uv.CStrings.String(cString);
                }
            }
        }

        [FieldOffset(256)] // size = 256, padding = 0
        public fixed byte _release[256 / 1]; // char[256]

        public string release
        {
            get
            {
                fixed (uv_utsname_t* @this = &this)
                {
                    var pointer = &@this->_release[0];
                    var cString = new CString(pointer);
                    return uv.CStrings.String(cString);
                }
            }
        }

        [FieldOffset(512)] // size = 256, padding = 0
        public fixed byte _version[256 / 1]; // char[256]

        public string version
        {
            get
            {
                fixed (uv_utsname_t* @this = &this)
                {
                    var pointer = &@this->_version[0];
                    var cString = new CString(pointer);
                    return uv.CStrings.String(cString);
                }
            }
        }

        [FieldOffset(768)] // size = 256, padding = 0
        public fixed byte _machine[256 / 1]; // char[256]

        public string machine
        {
            get
            {
                fixed (uv_utsname_t* @this = &this)
                {
                    var pointer = &@this->_machine[0];
                    var cString = new CString(pointer);
                    return uv.CStrings.String(cString);
                }
            }
        }
    }

    // Struct @ uv.h:240:24
    [StructLayout(LayoutKind.Explicit, Size = 440, Pack = 8)]
    public struct uv_fs_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public void* data;

        [FieldOffset(8)] // size = 4, padding = 4
        public uv_req_type type;

        [FieldOffset(16)] // size = 48, padding = 0
        public fixed ulong _reserved[48 / 8]; // void*[6]

        public Span<nint> reserved
        {
            get
            {
                fixed (uv_fs_t* @this = &this)
                {
                    var pointer = &@this->_reserved[0];
                    var span = new Span<nint>(pointer, 6);
                    return span;
                }
            }
        }

        [FieldOffset(64)] // size = 4, padding = 4
        public uv_fs_type fs_type;

        [FieldOffset(72)] // size = 8, padding = 0
        public uv_loop_t* loop;

        [FieldOffset(80)] // size = 8, padding = 0
        public uv_fs_cb cb;

        [FieldOffset(88)] // size = 8, padding = 0
        public long result;

        [FieldOffset(96)] // size = 8, padding = 0
        public void* ptr;

        [FieldOffset(104)] // size = 8, padding = 0
        public CString path;

        [FieldOffset(112)] // size = 160, padding = 0
        public uv_stat_t statbuf;

        [FieldOffset(272)] // size = 8, padding = 0
        public CString new_path;

        [FieldOffset(280)] // size = 4, padding = 0
        public uv_file file;

        [FieldOffset(284)] // size = 4, padding = 0
        public int flags;

        [FieldOffset(288)] // size = 4, padding = 0
        public mode_t mode;

        [FieldOffset(292)] // size = 4, padding = 0
        public uint nbufs;

        [FieldOffset(296)] // size = 8, padding = 0
        public uv_buf_t* bufs;

        [FieldOffset(304)] // size = 8, padding = 0
        public off_t off;

        [FieldOffset(312)] // size = 4, padding = 0
        public uv_uid_t uid;

        [FieldOffset(316)] // size = 4, padding = 0
        public uv_gid_t gid;

        [FieldOffset(320)] // size = 8, padding = 0
        public double atime;

        [FieldOffset(328)] // size = 8, padding = 0
        public double mtime;

        [FieldOffset(336)] // size = 40, padding = 0
        public uv__work work_req;

        [FieldOffset(376)] // size = 64, padding = 0
        public fixed ulong _bufsml[64 / 8]; // uv_buf_t[4]

        public Span<uv_buf_t> bufsml
        {
            get
            {
                fixed (uv_fs_t* @this = &this)
                {
                    var pointer = &@this->_bufsml[0];
                    var span = new Span<uv_buf_t>(pointer, 4);
                    return span;
                }
            }
        }
    }

    // Struct @ uv.h:370:3
    [StructLayout(LayoutKind.Explicit, Size = 160, Pack = 8)]
    public struct uv_stat_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public ulong st_dev;

        [FieldOffset(8)] // size = 8, padding = 0
        public ulong st_mode;

        [FieldOffset(16)] // size = 8, padding = 0
        public ulong st_nlink;

        [FieldOffset(24)] // size = 8, padding = 0
        public ulong st_uid;

        [FieldOffset(32)] // size = 8, padding = 0
        public ulong st_gid;

        [FieldOffset(40)] // size = 8, padding = 0
        public ulong st_rdev;

        [FieldOffset(48)] // size = 8, padding = 0
        public ulong st_ino;

        [FieldOffset(56)] // size = 8, padding = 0
        public ulong st_size;

        [FieldOffset(64)] // size = 8, padding = 0
        public ulong st_blksize;

        [FieldOffset(72)] // size = 8, padding = 0
        public ulong st_blocks;

        [FieldOffset(80)] // size = 8, padding = 0
        public ulong st_flags;

        [FieldOffset(88)] // size = 8, padding = 0
        public ulong st_gen;

        [FieldOffset(96)] // size = 16, padding = 0
        public uv_timespec_t st_atim;

        [FieldOffset(112)] // size = 16, padding = 0
        public uv_timespec_t st_mtim;

        [FieldOffset(128)] // size = 16, padding = 0
        public uv_timespec_t st_ctim;

        [FieldOffset(144)] // size = 16, padding = 0
        public uv_timespec_t st_birthtim;
    }

    // Struct @ uv.h:248:28
    [StructLayout(LayoutKind.Explicit, Size = 16, Pack = 8)]
    public struct uv_dirent_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public CString name;

        [FieldOffset(8)] // size = 4, padding = 4
        public uv_dirent_type_t type;
    }

    // Struct @ uv.h:215:25
    [StructLayout(LayoutKind.Explicit, Size = 56, Pack = 8)]
    public struct uv_dir_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public uv_dirent_t* dirents;

        [FieldOffset(8)] // size = 8, padding = 0
        public ulong nentries;

        [FieldOffset(16)] // size = 32, padding = 0
        public fixed ulong _reserved[32 / 8]; // void*[4]

        public Span<nint> reserved
        {
            get
            {
                fixed (uv_dir_t* @this = &this)
                {
                    var pointer = &@this->_reserved[0];
                    var span = new Span<nint>(pointer, 4);
                    return span;
                }
            }
        }

        [FieldOffset(48)] // size = 8, padding = 0
        public nint dir;
    }

    // Struct @ uv.h:229:29
    [StructLayout(LayoutKind.Explicit, Size = 104, Pack = 8)]
    public struct uv_fs_poll_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public void* data;

        [FieldOffset(8)] // size = 8, padding = 0
        public uv_loop_t* loop;

        [FieldOffset(16)] // size = 4, padding = 4
        public uv_handle_type type;

        [FieldOffset(24)] // size = 8, padding = 0
        public uv_close_cb close_cb;

        [FieldOffset(32)] // size = 16, padding = 0
        public fixed ulong _handle_queue[16 / 8]; // void*[2]

        public Span<nint> handle_queue
        {
            get
            {
                fixed (uv_fs_poll_t* @this = &this)
                {
                    var pointer = &@this->_handle_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(48)] // size = 32, padding = 0
        public uv_fs_poll_t_u u;

        [FieldOffset(80)] // size = 8, padding = 0
        public uv_handle_t* next_closing;

        [FieldOffset(88)] // size = 4, padding = 4
        public uint flags;

        [FieldOffset(96)] // size = 8, padding = 0
        public void* poll_ctx;

        // Union @ uv.h:1582:3
        [StructLayout(LayoutKind.Explicit, Size = 32, Pack = 8)]
        public struct uv_fs_poll_t_u
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public int fd;

            [FieldOffset(0)] // size = 32, padding = 0
            public fixed ulong _reserved[32 / 8]; // void*[4]

            public Span<nint> reserved
            {
                get
                {
                    fixed (uv_fs_poll_t_u* @this = &this)
                    {
                        var pointer = &@this->_reserved[0];
                        var span = new Span<nint>(pointer, 4);
                        return span;
                    }
                }
            }
        }
    }

    // Struct @ uv.h:230:28
    [StructLayout(LayoutKind.Explicit, Size = 152, Pack = 8)]
    public struct uv_signal_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public void* data;

        [FieldOffset(8)] // size = 8, padding = 0
        public uv_loop_t* loop;

        [FieldOffset(16)] // size = 4, padding = 4
        public uv_handle_type type;

        [FieldOffset(24)] // size = 8, padding = 0
        public uv_close_cb close_cb;

        [FieldOffset(32)] // size = 16, padding = 0
        public fixed ulong _handle_queue[16 / 8]; // void*[2]

        public Span<nint> handle_queue
        {
            get
            {
                fixed (uv_signal_t* @this = &this)
                {
                    var pointer = &@this->_handle_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(48)] // size = 32, padding = 0
        public uv_signal_t_u u;

        [FieldOffset(80)] // size = 8, padding = 0
        public uv_handle_t* next_closing;

        [FieldOffset(88)] // size = 4, padding = 4
        public uint flags;

        [FieldOffset(96)] // size = 8, padding = 0
        public uv_signal_cb signal_cb;

        [FieldOffset(104)] // size = 4, padding = 4
        public int signum;

        [FieldOffset(112)] // size = 32, padding = 0
        public uv_signal_t_tree_entry tree_entry;

        [FieldOffset(144)] // size = 4, padding = 0
        public uint caught_signals;

        [FieldOffset(148)] // size = 4, padding = 0
        public uint dispatched_signals;

        // Union @ uv.h:1599:3
        [StructLayout(LayoutKind.Explicit, Size = 32, Pack = 8)]
        public struct uv_signal_t_u
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public int fd;

            [FieldOffset(0)] // size = 32, padding = 0
            public fixed ulong _reserved[32 / 8]; // void*[4]

            public Span<nint> reserved
            {
                get
                {
                    fixed (uv_signal_t_u* @this = &this)
                    {
                        var pointer = &@this->_reserved[0];
                        var span = new Span<nint>(pointer, 4);
                        return span;
                    }
                }
            }
        }

        // Struct @ uv.h:1602:3
        [StructLayout(LayoutKind.Explicit, Size = 32, Pack = 8)]
        public struct uv_signal_t_tree_entry
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public uv_signal_s* rbe_left;

            [FieldOffset(8)] // size = 8, padding = 0
            public uv_signal_s* rbe_right;

            [FieldOffset(16)] // size = 8, padding = 0
            public uv_signal_s* rbe_parent;

            [FieldOffset(24)] // size = 4, padding = 4
            public int rbe_color;
        }
    }

    // Struct @ uv.h:228:30
    [StructLayout(LayoutKind.Explicit, Size = 136, Pack = 8)]
    public struct uv_fs_event_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public void* data;

        [FieldOffset(8)] // size = 8, padding = 0
        public uv_loop_t* loop;

        [FieldOffset(16)] // size = 4, padding = 4
        public uv_handle_type type;

        [FieldOffset(24)] // size = 8, padding = 0
        public uv_close_cb close_cb;

        [FieldOffset(32)] // size = 16, padding = 0
        public fixed ulong _handle_queue[16 / 8]; // void*[2]

        public Span<nint> handle_queue
        {
            get
            {
                fixed (uv_fs_event_t* @this = &this)
                {
                    var pointer = &@this->_handle_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(48)] // size = 32, padding = 0
        public uv_fs_event_t_u u;

        [FieldOffset(80)] // size = 8, padding = 0
        public uv_handle_t* next_closing;

        [FieldOffset(88)] // size = 4, padding = 4
        public uint flags;

        [FieldOffset(96)] // size = 8, padding = 0
        public CString path;

        [FieldOffset(104)] // size = 8, padding = 0
        public uv_fs_event_cb cb;

        [FieldOffset(112)] // size = 16, padding = 0
        public fixed ulong _watchers[16 / 8]; // void*[2]

        public Span<nint> watchers
        {
            get
            {
                fixed (uv_fs_event_t* @this = &this)
                {
                    var pointer = &@this->_watchers[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(128)] // size = 4, padding = 4
        public int wd;

        // Union @ uv.h:1571:3
        [StructLayout(LayoutKind.Explicit, Size = 32, Pack = 8)]
        public struct uv_fs_event_t_u
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public int fd;

            [FieldOffset(0)] // size = 32, padding = 0
            public fixed ulong _reserved[32 / 8]; // void*[4]

            public Span<nint> reserved
            {
                get
                {
                    fixed (uv_fs_event_t_u* @this = &this)
                    {
                        var pointer = &@this->_reserved[0];
                        var span = new Span<nint>(pointer, 4);
                        return span;
                    }
                }
            }
        }
    }

    // Struct @ in.h:238:8 (/usr/include/netinet/in.h)
    [StructLayout(LayoutKind.Explicit, Size = 16, Pack = 4)]
    public struct sockaddr_in
    {
        [FieldOffset(0)] // size = 2, padding = 0
        public sa_family_t sin_family;

        [FieldOffset(2)] // size = 2, padding = 0
        public in_port_t sin_port;

        [FieldOffset(4)] // size = 4, padding = 0
        public in_addr sin_addr;

        [FieldOffset(8)] // size = 8, padding = 0
        public fixed byte _sin_zero[8 / 1]; // unsigned char[8]

        public Span<byte> sin_zero
        {
            get
            {
                fixed (sockaddr_in* @this = &this)
                {
                    var pointer = &@this->_sin_zero[0];
                    var span = new Span<byte>(pointer, 8);
                    return span;
                }
            }
        }
    }

    // Struct @ in.h:253:8 (/usr/include/netinet/in.h)
    [StructLayout(LayoutKind.Explicit, Size = 28, Pack = 4)]
    public struct sockaddr_in6
    {
        [FieldOffset(0)] // size = 2, padding = 0
        public sa_family_t sin6_family;

        [FieldOffset(2)] // size = 2, padding = 0
        public in_port_t sin6_port;

        [FieldOffset(4)] // size = 4, padding = 0
        public uint sin6_flowinfo;

        [FieldOffset(8)] // size = 16, padding = 0
        public in6_addr sin6_addr;

        [FieldOffset(24)] // size = 4, padding = 0
        public uint sin6_scope_id;
    }

    // Struct @ uv.h:242:28
    [StructLayout(LayoutKind.Explicit, Size = 144, Pack = 8)]
    public struct uv_random_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public void* data;

        [FieldOffset(8)] // size = 4, padding = 4
        public uv_req_type type;

        [FieldOffset(16)] // size = 48, padding = 0
        public fixed ulong _reserved[48 / 8]; // void*[6]

        public Span<nint> reserved
        {
            get
            {
                fixed (uv_random_t* @this = &this)
                {
                    var pointer = &@this->_reserved[0];
                    var span = new Span<nint>(pointer, 6);
                    return span;
                }
            }
        }

        [FieldOffset(64)] // size = 8, padding = 0
        public uv_loop_t* loop;

        [FieldOffset(72)] // size = 4, padding = 4
        public int status;

        [FieldOffset(80)] // size = 8, padding = 0
        public void* buf;

        [FieldOffset(88)] // size = 8, padding = 0
        public ulong buflen;

        [FieldOffset(96)] // size = 8, padding = 0
        public uv_random_cb cb;

        [FieldOffset(104)] // size = 40, padding = 0
        public uv__work work_req;
    }

    // Struct @ unix.h:219:3 (uv/unix.h)
    [StructLayout(LayoutKind.Explicit, Size = 16, Pack = 8)]
    public struct uv_lib_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public void* handle;

        [FieldOffset(8)] // size = 8, padding = 0
        public CString errmsg;
    }

    // Struct @ uv.h:1195:3
    [StructLayout(LayoutKind.Explicit, Size = 16, Pack = 8)]
    public struct uv_timeval64_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public long tv_sec;

        [FieldOffset(8)] // size = 4, padding = 4
        public int tv_usec;
    }

    // Struct @ uv.h:1783:36
    [StructLayout(LayoutKind.Explicit, Size = 16, Pack = 8)]
    public struct uv_thread_options_t
    {
        [FieldOffset(0)] // size = 4, padding = 4
        public uint flags;

        [FieldOffset(8)] // size = 8, padding = 0
        public ulong stack_size;
    }

    // Struct @ unix.h:92:25 (uv/unix.h)
    [StructLayout(LayoutKind.Explicit, Size = 56, Pack = 8)]
    public struct uv__io_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public uv__io_cb cb;

        [FieldOffset(8)] // size = 16, padding = 0
        public fixed ulong _pending_queue[16 / 8]; // void*[2]

        public Span<nint> pending_queue
        {
            get
            {
                fixed (uv__io_t* @this = &this)
                {
                    var pointer = &@this->_pending_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(24)] // size = 16, padding = 0
        public fixed ulong _watcher_queue[16 / 8]; // void*[2]

        public Span<nint> watcher_queue
        {
            get
            {
                fixed (uv__io_t* @this = &this)
                {
                    var pointer = &@this->_watcher_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(40)] // size = 4, padding = 0
        public uint pevents;

        [FieldOffset(44)] // size = 4, padding = 0
        public uint events;

        [FieldOffset(48)] // size = 4, padding = 4
        public int fd;
    }

    // Struct @ socket.h:191:8 (/usr/include/x86_64-linux-gnu/bits/socket.h)
    [StructLayout(LayoutKind.Explicit, Size = 128, Pack = 8)]
    public struct sockaddr_storage
    {
        [FieldOffset(0)] // size = 2, padding = 0
        public sa_family_t ss_family;

        [FieldOffset(2)] // size = 118, padding = 0
        public fixed byte ___ss_padding[118 / 1]; // char[118]

        public string __ss_padding
        {
            get
            {
                fixed (sockaddr_storage* @this = &this)
                {
                    var pointer = &@this->___ss_padding[0];
                    var cString = new CString(pointer);
                    return uv.CStrings.String(cString);
                }
            }
        }

        [FieldOffset(120)] // size = 8, padding = 0
        public ulong __ss_align;
    }

    // Struct @ termios-struct.h:24:8 (/usr/include/x86_64-linux-gnu/bits/termios-struct.h)
    [StructLayout(LayoutKind.Explicit, Size = 60, Pack = 4)]
    public struct termios
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public tcflag_t c_iflag;

        [FieldOffset(4)] // size = 4, padding = 0
        public tcflag_t c_oflag;

        [FieldOffset(8)] // size = 4, padding = 0
        public tcflag_t c_cflag;

        [FieldOffset(12)] // size = 4, padding = 0
        public tcflag_t c_lflag;

        [FieldOffset(16)] // size = 1, padding = 0
        public cc_t c_line;

        [FieldOffset(17)] // size = 32, padding = 3
        public fixed byte _c_cc[32 / 1]; // cc_t[32]

        public Span<cc_t> c_cc
        {
            get
            {
                fixed (termios* @this = &this)
                {
                    var pointer = &@this->_c_cc[0];
                    var span = new Span<cc_t>(pointer, 32);
                    return span;
                }
            }
        }

        [FieldOffset(52)] // size = 4, padding = 0
        public speed_t c_ispeed;

        [FieldOffset(56)] // size = 4, padding = 0
        public speed_t c_ospeed;
    }

    // Struct @ threadpool.h:30:8 (uv/threadpool.h)
    [StructLayout(LayoutKind.Explicit, Size = 40, Pack = 8)]
    public struct uv__work
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public FnPtr_UV_Uv_workPtr_Void work;

        [FieldOffset(8)] // size = 8, padding = 0
        public FnPtr_UV_Uv_workPtr_Int_Void done;

        [FieldOffset(16)] // size = 8, padding = 0
        public uv_loop_s* loop;

        [FieldOffset(24)] // size = 16, padding = 0
        public fixed ulong _wq[16 / 8]; // void*[2]

        public Span<nint> wq
        {
            get
            {
                fixed (uv__work* @this = &this)
                {
                    var pointer = &@this->_wq[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }
    }

    // Struct @ uv.h:973:3
    [StructLayout(LayoutKind.Explicit, Size = 16, Pack = 8)]
    public struct uv_stdio_container_t
    {
        [FieldOffset(0)] // size = 4, padding = 4
        public uv_stdio_flags flags;

        [FieldOffset(8)] // size = 8, padding = 0
        public uv_stdio_container_t_data data;

        // Union @ uv.h:969:3
        [StructLayout(LayoutKind.Explicit, Size = 8, Pack = 8)]
        public struct uv_stdio_container_t_data
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public uv_stream_t* stream;

            [FieldOffset(0)] // size = 4, padding = 4
            public int fd;
        }
    }

    // Struct @ uv.h:1190:3
    [StructLayout(LayoutKind.Explicit, Size = 16, Pack = 8)]
    public struct uv_timeval_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public long tv_sec;

        [FieldOffset(8)] // size = 8, padding = 0
        public long tv_usec;
    }

    // Struct @ uv.h:1106:8
    [StructLayout(LayoutKind.Explicit, Size = 40, Pack = 8)]
    public struct uv_cpu_times_s
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public ulong user;

        [FieldOffset(8)] // size = 8, padding = 0
        public ulong nice;

        [FieldOffset(16)] // size = 8, padding = 0
        public ulong sys;

        [FieldOffset(24)] // size = 8, padding = 0
        public ulong idle;

        [FieldOffset(32)] // size = 8, padding = 0
        public ulong irq;
    }

    // Struct @ uv.h:350:3
    [StructLayout(LayoutKind.Explicit, Size = 16, Pack = 8)]
    public struct uv_timespec_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public long tv_sec;

        [FieldOffset(8)] // size = 8, padding = 0
        public long tv_nsec;
    }

    // Struct @ uv.h:1598:8
    [StructLayout(LayoutKind.Explicit, Size = 152, Pack = 8)]
    public struct uv_signal_s
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public void* data;

        [FieldOffset(8)] // size = 8, padding = 0
        public uv_loop_t* loop;

        [FieldOffset(16)] // size = 4, padding = 4
        public uv_handle_type type;

        [FieldOffset(24)] // size = 8, padding = 0
        public uv_close_cb close_cb;

        [FieldOffset(32)] // size = 16, padding = 0
        public fixed ulong _handle_queue[16 / 8]; // void*[2]

        public Span<nint> handle_queue
        {
            get
            {
                fixed (uv_signal_s* @this = &this)
                {
                    var pointer = &@this->_handle_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(48)] // size = 32, padding = 0
        public uv_signal_s_u u;

        [FieldOffset(80)] // size = 8, padding = 0
        public uv_handle_t* next_closing;

        [FieldOffset(88)] // size = 4, padding = 4
        public uint flags;

        [FieldOffset(96)] // size = 8, padding = 0
        public uv_signal_cb signal_cb;

        [FieldOffset(104)] // size = 4, padding = 4
        public int signum;

        [FieldOffset(112)] // size = 32, padding = 0
        public uv_signal_s_tree_entry tree_entry;

        [FieldOffset(144)] // size = 4, padding = 0
        public uint caught_signals;

        [FieldOffset(148)] // size = 4, padding = 0
        public uint dispatched_signals;

        // Union @ uv.h:1599:3
        [StructLayout(LayoutKind.Explicit, Size = 32, Pack = 8)]
        public struct uv_signal_s_u
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public int fd;

            [FieldOffset(0)] // size = 32, padding = 0
            public fixed ulong _reserved[32 / 8]; // void*[4]

            public Span<nint> reserved
            {
                get
                {
                    fixed (uv_signal_s_u* @this = &this)
                    {
                        var pointer = &@this->_reserved[0];
                        var span = new Span<nint>(pointer, 4);
                        return span;
                    }
                }
            }
        }

        // Struct @ uv.h:1602:3
        [StructLayout(LayoutKind.Explicit, Size = 32, Pack = 8)]
        public struct uv_signal_s_tree_entry
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public uv_signal_s* rbe_left;

            [FieldOffset(8)] // size = 8, padding = 0
            public uv_signal_s* rbe_right;

            [FieldOffset(16)] // size = 8, padding = 0
            public uv_signal_s* rbe_parent;

            [FieldOffset(24)] // size = 4, padding = 4
            public int rbe_color;
        }
    }

    // Struct @ in.h:31:8 (/usr/include/netinet/in.h)
    [StructLayout(LayoutKind.Explicit, Size = 4, Pack = 4)]
    public struct in_addr
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public in_addr_t s_addr;
    }

    // Struct @ in.h:212:8 (/usr/include/netinet/in.h)
    [StructLayout(LayoutKind.Explicit, Size = 16, Pack = 4)]
    public struct in6_addr
    {
        [FieldOffset(0)] // size = 16, padding = 0
        public in6_addr___in6_u __in6_u;

        // Union @ in.h:214:5 (/usr/include/netinet/in.h)
        [StructLayout(LayoutKind.Explicit, Size = 16, Pack = 4)]
        public struct in6_addr___in6_u
        {
            [FieldOffset(0)] // size = 16, padding = 0
            public fixed byte ___u6_addr8[16 / 1]; // uint8_t[16]

            public Span<byte> __u6_addr8
            {
                get
                {
                    fixed (in6_addr___in6_u* @this = &this)
                    {
                        var pointer = &@this->___u6_addr8[0];
                        var span = new Span<byte>(pointer, 16);
                        return span;
                    }
                }
            }

            [FieldOffset(0)] // size = 16, padding = 0
            public fixed ushort ___u6_addr16[16 / 2]; // uint16_t[8]

            public Span<ushort> __u6_addr16
            {
                get
                {
                    fixed (in6_addr___in6_u* @this = &this)
                    {
                        var pointer = &@this->___u6_addr16[0];
                        var span = new Span<ushort>(pointer, 8);
                        return span;
                    }
                }
            }

            [FieldOffset(0)] // size = 16, padding = 0
            public fixed uint ___u6_addr32[16 / 4]; // uint32_t[4]

            public Span<uint> __u6_addr32
            {
                get
                {
                    fixed (in6_addr___in6_u* @this = &this)
                    {
                        var pointer = &@this->___u6_addr32[0];
                        var span = new Span<uint>(pointer, 4);
                        return span;
                    }
                }
            }
        }
    }

    // Struct @ pthreadtypes.h:72:3 (/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h)
    [StructLayout(LayoutKind.Explicit, Size = 40, Pack = 8)]
    public struct pthread_mutex_t
    {
        [FieldOffset(0)] // size = 40, padding = 0
        public __pthread_mutex_s __data;

        [FieldOffset(0)] // size = 40, padding = 0
        public fixed byte ___size[40 / 1]; // char[40]

        public string __size
        {
            get
            {
                fixed (pthread_mutex_t* @this = &this)
                {
                    var pointer = &@this->___size[0];
                    var cString = new CString(pointer);
                    return uv.CStrings.String(cString);
                }
            }
        }

        [FieldOffset(0)] // size = 8, padding = 32
        public long __align;
    }

    // Struct @ pthreadtypes.h:91:3 (/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h)
    [StructLayout(LayoutKind.Explicit, Size = 56, Pack = 8)]
    public struct pthread_rwlock_t
    {
        [FieldOffset(0)] // size = 56, padding = 0
        public __pthread_rwlock_arch_t __data;

        [FieldOffset(0)] // size = 56, padding = 0
        public fixed byte ___size[56 / 1]; // char[56]

        public string __size
        {
            get
            {
                fixed (pthread_rwlock_t* @this = &this)
                {
                    var pointer = &@this->___size[0];
                    var cString = new CString(pointer);
                    return uv.CStrings.String(cString);
                }
            }
        }

        [FieldOffset(0)] // size = 8, padding = 48
        public long __align;
    }

    // Struct @ semaphore.h:40:3 (/usr/include/x86_64-linux-gnu/bits/semaphore.h)
    [StructLayout(LayoutKind.Explicit, Size = 32, Pack = 8)]
    public struct sem_t
    {
        [FieldOffset(0)] // size = 32, padding = 0
        public fixed byte ___size[32 / 1]; // char[32]

        public string __size
        {
            get
            {
                fixed (sem_t* @this = &this)
                {
                    var pointer = &@this->___size[0];
                    var cString = new CString(pointer);
                    return uv.CStrings.String(cString);
                }
            }
        }

        [FieldOffset(0)] // size = 8, padding = 24
        public long __align;
    }

    // Struct @ pthreadtypes.h:80:3 (/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h)
    [StructLayout(LayoutKind.Explicit, Size = 48, Pack = 8)]
    public struct pthread_cond_t
    {
        [FieldOffset(0)] // size = 48, padding = 0
        public __pthread_cond_s __data;

        [FieldOffset(0)] // size = 48, padding = 0
        public fixed byte ___size[48 / 1]; // char[48]

        public string __size
        {
            get
            {
                fixed (pthread_cond_t* @this = &this)
                {
                    var pointer = &@this->___size[0];
                    var cString = new CString(pointer);
                    return uv.CStrings.String(cString);
                }
            }
        }

        [FieldOffset(0)] // size = 8, padding = 40
        public long __align;
    }

    // Struct @ pthreadtypes.h:112:3 (/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h)
    [StructLayout(LayoutKind.Explicit, Size = 32, Pack = 8)]
    public struct pthread_barrier_t
    {
        [FieldOffset(0)] // size = 32, padding = 0
        public fixed byte ___size[32 / 1]; // char[32]

        public string __size
        {
            get
            {
                fixed (pthread_barrier_t* @this = &this)
                {
                    var pointer = &@this->___size[0];
                    var cString = new CString(pointer);
                    return uv.CStrings.String(cString);
                }
            }
        }

        [FieldOffset(0)] // size = 8, padding = 24
        public long __align;
    }

    // Struct @ uv.h:1805:8
    [StructLayout(LayoutKind.Explicit, Size = 848, Pack = 8)]
    public struct uv_loop_s
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public void* data;

        [FieldOffset(8)] // size = 4, padding = 4
        public uint active_handles;

        [FieldOffset(16)] // size = 16, padding = 0
        public fixed ulong _handle_queue[16 / 8]; // void*[2]

        public Span<nint> handle_queue
        {
            get
            {
                fixed (uv_loop_s* @this = &this)
                {
                    var pointer = &@this->_handle_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(32)] // size = 8, padding = 0
        public uv_loop_s_active_reqs active_reqs;

        [FieldOffset(40)] // size = 8, padding = 0
        public void* internal_fields;

        [FieldOffset(48)] // size = 4, padding = 4
        public uint stop_flag;

        [FieldOffset(56)] // size = 8, padding = 0
        public ulong flags;

        [FieldOffset(64)] // size = 4, padding = 4
        public int backend_fd;

        [FieldOffset(72)] // size = 16, padding = 0
        public fixed ulong _pending_queue[16 / 8]; // void*[2]

        public Span<nint> pending_queue
        {
            get
            {
                fixed (uv_loop_s* @this = &this)
                {
                    var pointer = &@this->_pending_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(88)] // size = 16, padding = 0
        public fixed ulong _watcher_queue[16 / 8]; // void*[2]

        public Span<nint> watcher_queue
        {
            get
            {
                fixed (uv_loop_s* @this = &this)
                {
                    var pointer = &@this->_watcher_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(104)] // size = 8, padding = 0
        public uv__io_t** watchers;

        [FieldOffset(112)] // size = 4, padding = 0
        public uint nwatchers;

        [FieldOffset(116)] // size = 4, padding = 0
        public uint nfds;

        [FieldOffset(120)] // size = 16, padding = 0
        public fixed ulong _wq[16 / 8]; // void*[2]

        public Span<nint> wq
        {
            get
            {
                fixed (uv_loop_s* @this = &this)
                {
                    var pointer = &@this->_wq[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(136)] // size = 40, padding = 0
        public uv_mutex_t wq_mutex;

        [FieldOffset(176)] // size = 128, padding = 0
        public uv_async_t wq_async;

        [FieldOffset(304)] // size = 56, padding = 0
        public uv_rwlock_t cloexec_lock;

        [FieldOffset(360)] // size = 8, padding = 0
        public uv_handle_t* closing_handles;

        [FieldOffset(368)] // size = 16, padding = 0
        public fixed ulong _process_handles[16 / 8]; // void*[2]

        public Span<nint> process_handles
        {
            get
            {
                fixed (uv_loop_s* @this = &this)
                {
                    var pointer = &@this->_process_handles[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(384)] // size = 16, padding = 0
        public fixed ulong _prepare_handles[16 / 8]; // void*[2]

        public Span<nint> prepare_handles
        {
            get
            {
                fixed (uv_loop_s* @this = &this)
                {
                    var pointer = &@this->_prepare_handles[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(400)] // size = 16, padding = 0
        public fixed ulong _check_handles[16 / 8]; // void*[2]

        public Span<nint> check_handles
        {
            get
            {
                fixed (uv_loop_s* @this = &this)
                {
                    var pointer = &@this->_check_handles[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(416)] // size = 16, padding = 0
        public fixed ulong _idle_handles[16 / 8]; // void*[2]

        public Span<nint> idle_handles
        {
            get
            {
                fixed (uv_loop_s* @this = &this)
                {
                    var pointer = &@this->_idle_handles[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(432)] // size = 16, padding = 0
        public fixed ulong _async_handles[16 / 8]; // void*[2]

        public Span<nint> async_handles
        {
            get
            {
                fixed (uv_loop_s* @this = &this)
                {
                    var pointer = &@this->_async_handles[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(448)] // size = 8, padding = 0
        public FnPtr_UV_Void async_unused;

        [FieldOffset(456)] // size = 56, padding = 0
        public uv__io_t async_io_watcher;

        [FieldOffset(512)] // size = 4, padding = 4
        public int async_wfd;

        [FieldOffset(520)] // size = 16, padding = 0
        public uv_loop_s_timer_heap timer_heap;

        [FieldOffset(536)] // size = 8, padding = 0
        public ulong timer_counter;

        [FieldOffset(544)] // size = 8, padding = 0
        public ulong time;

        [FieldOffset(552)] // size = 8, padding = 0
        public fixed uint _signal_pipefd[8 / 4]; // int[2]

        public Span<int> signal_pipefd
        {
            get
            {
                fixed (uv_loop_s* @this = &this)
                {
                    var pointer = &@this->_signal_pipefd[0];
                    var span = new Span<int>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(560)] // size = 56, padding = 0
        public uv__io_t signal_io_watcher;

        [FieldOffset(616)] // size = 152, padding = 0
        public uv_signal_t child_watcher;

        [FieldOffset(768)] // size = 4, padding = 4
        public int emfile_fd;

        [FieldOffset(776)] // size = 56, padding = 0
        public uv__io_t inotify_read_watcher;

        [FieldOffset(832)] // size = 8, padding = 0
        public void* inotify_watchers;

        [FieldOffset(840)] // size = 4, padding = 4
        public int inotify_fd;

        // Union @ uv.h:1811:3
        [StructLayout(LayoutKind.Explicit, Size = 8, Pack = 8)]
        public struct uv_loop_s_active_reqs
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public void* unused;

            [FieldOffset(0)] // size = 4, padding = 4
            public uint count;
        }

        // Struct @ uv.h:1819:3
        [StructLayout(LayoutKind.Explicit, Size = 16, Pack = 8)]
        public struct uv_loop_s_timer_heap
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public void* min;

            [FieldOffset(8)] // size = 4, padding = 4
            public uint nelts;
        }
    }

    // Struct @ struct_mutex.h:22:8 (/usr/include/x86_64-linux-gnu/bits/struct_mutex.h)
    [StructLayout(LayoutKind.Explicit, Size = 40, Pack = 8)]
    public struct __pthread_mutex_s
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public int __lock;

        [FieldOffset(4)] // size = 4, padding = 0
        public uint __count;

        [FieldOffset(8)] // size = 4, padding = 0
        public int __owner;

        [FieldOffset(12)] // size = 4, padding = 0
        public uint __nusers;

        [FieldOffset(16)] // size = 4, padding = 0
        public int __kind;

        [FieldOffset(20)] // size = 2, padding = 0
        public short __spins;

        [FieldOffset(22)] // size = 2, padding = 0
        public short __elision;

        [FieldOffset(24)] // size = 16, padding = 0
        public __pthread_list_t __list;
    }

    // Struct @ struct_rwlock.h:23:8 (/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h)
    [StructLayout(LayoutKind.Explicit, Size = 56, Pack = 8)]
    public struct __pthread_rwlock_arch_t
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public uint __readers;

        [FieldOffset(4)] // size = 4, padding = 0
        public uint __writers;

        [FieldOffset(8)] // size = 4, padding = 0
        public uint __wrphase_futex;

        [FieldOffset(12)] // size = 4, padding = 0
        public uint __writers_futex;

        [FieldOffset(16)] // size = 4, padding = 0
        public uint __pad3;

        [FieldOffset(20)] // size = 4, padding = 0
        public uint __pad4;

        [FieldOffset(24)] // size = 4, padding = 0
        public int __cur_writer;

        [FieldOffset(28)] // size = 4, padding = 0
        public int __shared;

        [FieldOffset(32)] // size = 1, padding = 0
        public sbyte __rwelision;

        [FieldOffset(33)] // size = 7, padding = 0
        public fixed byte ___pad1[7 / 1]; // unsigned char[7]

        public Span<byte> __pad1
        {
            get
            {
                fixed (__pthread_rwlock_arch_t* @this = &this)
                {
                    var pointer = &@this->___pad1[0];
                    var span = new Span<byte>(pointer, 7);
                    return span;
                }
            }
        }

        [FieldOffset(40)] // size = 8, padding = 0
        public ulong __pad2;

        [FieldOffset(48)] // size = 4, padding = 4
        public uint __flags;
    }

    // Struct @ thread-shared-types.h:92:8 (/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h)
    [StructLayout(LayoutKind.Explicit, Size = 48, Pack = 8)]
    public struct __pthread_cond_s
    {
        [FieldOffset(16)] // size = 8, padding = 0
        public fixed uint ___g_refs[8 / 4]; // unsigned int[2]

        public Span<uint> __g_refs
        {
            get
            {
                fixed (__pthread_cond_s* @this = &this)
                {
                    var pointer = &@this->___g_refs[0];
                    var span = new Span<uint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(24)] // size = 8, padding = 0
        public fixed uint ___g_size[8 / 4]; // unsigned int[2]

        public Span<uint> __g_size
        {
            get
            {
                fixed (__pthread_cond_s* @this = &this)
                {
                    var pointer = &@this->___g_size[0];
                    var span = new Span<uint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(32)] // size = 4, padding = 0
        public uint __g1_orig_size;

        [FieldOffset(36)] // size = 4, padding = 0
        public uint __wrefs;

        [FieldOffset(40)] // size = 8, padding = 0
        public fixed uint ___g_signals[8 / 4]; // unsigned int[2]

        public Span<uint> __g_signals
        {
            get
            {
                fixed (__pthread_cond_s* @this = &this)
                {
                    var pointer = &@this->___g_signals[0];
                    var span = new Span<uint>(pointer, 2);
                    return span;
                }
            }
        }
    }

    // Struct @ unix.h:94:8 (uv/unix.h)
    [StructLayout(LayoutKind.Explicit, Size = 56, Pack = 8)]
    public struct uv__io_s
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public uv__io_cb cb;

        [FieldOffset(8)] // size = 16, padding = 0
        public fixed ulong _pending_queue[16 / 8]; // void*[2]

        public Span<nint> pending_queue
        {
            get
            {
                fixed (uv__io_s* @this = &this)
                {
                    var pointer = &@this->_pending_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(24)] // size = 16, padding = 0
        public fixed ulong _watcher_queue[16 / 8]; // void*[2]

        public Span<nint> watcher_queue
        {
            get
            {
                fixed (uv__io_s* @this = &this)
                {
                    var pointer = &@this->_watcher_queue[0];
                    var span = new Span<nint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(40)] // size = 4, padding = 0
        public uint pevents;

        [FieldOffset(44)] // size = 4, padding = 0
        public uint events;

        [FieldOffset(48)] // size = 4, padding = 4
        public int fd;
    }

    // Struct @ thread-shared-types.h:53:3 (/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h)
    [StructLayout(LayoutKind.Explicit, Size = 16, Pack = 8)]
    public struct __pthread_list_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public __pthread_internal_list* __prev;

        [FieldOffset(8)] // size = 8, padding = 0
        public __pthread_internal_list* __next;
    }

    // Struct @ thread-shared-types.h:49:16 (/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h)
    [StructLayout(LayoutKind.Explicit, Size = 16, Pack = 8)]
    public struct __pthread_internal_list
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public __pthread_internal_list* __prev;

        [FieldOffset(8)] // size = 8, padding = 0
        public __pthread_internal_list* __next;
    }

    // Typedef @ unix.h:128:13 (uv/unix.h)
    [StructLayout(LayoutKind.Explicit, Size = 4, Pack = 4)]
    public struct uv_os_fd_t
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public int Data;

        public static implicit operator int(uv_os_fd_t data) => data.Data;
        public static implicit operator uv_os_fd_t(int data) => new() { Data = data };
    }

    // Typedef @ unix.h:127:13 (uv/unix.h)
    [StructLayout(LayoutKind.Explicit, Size = 4, Pack = 4)]
    public struct uv_os_sock_t
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public int Data;

        public static implicit operator int(uv_os_sock_t data) => data.Data;
        public static implicit operator uv_os_sock_t(int data) => new() { Data = data };
    }

    // Typedef @ unix.h:126:13 (uv/unix.h)
    [StructLayout(LayoutKind.Explicit, Size = 4, Pack = 4)]
    public struct uv_file
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public int Data;

        public static implicit operator int(uv_file data) => data.Data;
        public static implicit operator uv_file(int data) => new() { Data = data };
    }

    // Typedef @ unix.h:129:15 (uv/unix.h)
    [StructLayout(LayoutKind.Explicit, Size = 4, Pack = 4)]
    public struct uv_pid_t
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public pid_t Data;

        public static implicit operator pid_t(uv_pid_t data) => data.Data;
        public static implicit operator uv_pid_t(pid_t data) => new() { Data = data };
    }

    // Typedef @ unix.h:167:15 (uv/unix.h)
    [StructLayout(LayoutKind.Explicit, Size = 4, Pack = 4)]
    public struct uv_uid_t
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public uid_t Data;

        public static implicit operator uid_t(uv_uid_t data) => data.Data;
        public static implicit operator uv_uid_t(uid_t data) => new() { Data = data };
    }

    // Typedef @ unix.h:166:15 (uv/unix.h)
    [StructLayout(LayoutKind.Explicit, Size = 4, Pack = 4)]
    public struct uv_gid_t
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public gid_t Data;

        public static implicit operator gid_t(uv_gid_t data) => data.Data;
        public static implicit operator uv_gid_t(gid_t data) => new() { Data = data };
    }

    // Typedef @ unix.h:135:25 (uv/unix.h)
    [StructLayout(LayoutKind.Explicit, Size = 40, Pack = 8)]
    public struct uv_mutex_t
    {
        [FieldOffset(0)] // size = 40, padding = 0
        public pthread_mutex_t Data;

        public static implicit operator pthread_mutex_t(uv_mutex_t data) => data.Data;
        public static implicit operator uv_mutex_t(pthread_mutex_t data) => new() { Data = data };
    }

    // Typedef @ unix.h:136:26 (uv/unix.h)
    [StructLayout(LayoutKind.Explicit, Size = 56, Pack = 8)]
    public struct uv_rwlock_t
    {
        [FieldOffset(0)] // size = 56, padding = 0
        public pthread_rwlock_t Data;

        public static implicit operator pthread_rwlock_t(uv_rwlock_t data) => data.Data;
        public static implicit operator uv_rwlock_t(pthread_rwlock_t data) => new() { Data = data };
    }

    // Typedef @ unix.h:137:27 (uv/unix.h)
    [StructLayout(LayoutKind.Explicit, Size = 32, Pack = 8)]
    public struct uv_sem_t
    {
        [FieldOffset(0)] // size = 32, padding = 0
        public sem_t Data;

        public static implicit operator sem_t(uv_sem_t data) => data.Data;
        public static implicit operator uv_sem_t(sem_t data) => new() { Data = data };
    }

    // Typedef @ unix.h:138:24 (uv/unix.h)
    [StructLayout(LayoutKind.Explicit, Size = 48, Pack = 8)]
    public struct uv_cond_t
    {
        [FieldOffset(0)] // size = 48, padding = 0
        public pthread_cond_t Data;

        public static implicit operator pthread_cond_t(uv_cond_t data) => data.Data;
        public static implicit operator uv_cond_t(pthread_cond_t data) => new() { Data = data };
    }

    // Typedef @ unix.h:162:27 (uv/unix.h)
    [StructLayout(LayoutKind.Explicit, Size = 32, Pack = 8)]
    public struct uv_barrier_t
    {
        [FieldOffset(0)] // size = 32, padding = 0
        public pthread_barrier_t Data;

        public static implicit operator pthread_barrier_t(uv_barrier_t data) => data.Data;
        public static implicit operator uv_barrier_t(pthread_barrier_t data) => new() { Data = data };
    }

    // Typedef @ unix.h:133:24 (uv/unix.h)
    [StructLayout(LayoutKind.Explicit, Size = 4, Pack = 4)]
    public struct uv_once_t
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public pthread_once_t Data;

        public static implicit operator pthread_once_t(uv_once_t data) => data.Data;
        public static implicit operator uv_once_t(pthread_once_t data) => new() { Data = data };
    }

    // Typedef @ unix.h:139:23 (uv/unix.h)
    [StructLayout(LayoutKind.Explicit, Size = 4, Pack = 4)]
    public struct uv_key_t
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public pthread_key_t Data;

        public static implicit operator pthread_key_t(uv_key_t data) => data.Data;
        public static implicit operator uv_key_t(pthread_key_t data) => new() { Data = data };
    }

    // Typedef @ unix.h:134:19 (uv/unix.h)
    [StructLayout(LayoutKind.Explicit, Size = 8, Pack = 8)]
    public struct uv_thread_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public pthread_t Data;

        public static implicit operator pthread_t(uv_thread_t data) => data.Data;
        public static implicit operator uv_thread_t(pthread_t data) => new() { Data = data };
    }

    // Typedef @ sockaddr.h:28:28 (/usr/include/x86_64-linux-gnu/bits/sockaddr.h)
    [StructLayout(LayoutKind.Explicit, Size = 2, Pack = 2)]
    public struct sa_family_t
    {
        [FieldOffset(0)] // size = 2, padding = 0
        public ushort Data;

        public static implicit operator ushort(sa_family_t data) => data.Data;
        public static implicit operator sa_family_t(ushort data) => new() { Data = data };
    }

    // Typedef @ socket.h:33:21 (/usr/include/x86_64-linux-gnu/bits/socket.h)
    [StructLayout(LayoutKind.Explicit, Size = 4, Pack = 4)]
    public struct socklen_t
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public uint Data;

        public static implicit operator uint(socklen_t data) => data.Data;
        public static implicit operator socklen_t(uint data) => new() { Data = data };
    }

    // Typedef @ types.h:97:17 (/usr/include/x86_64-linux-gnu/sys/types.h)
    [StructLayout(LayoutKind.Explicit, Size = 4, Pack = 4)]
    public struct pid_t
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public int Data;

        public static implicit operator int(pid_t data) => data.Data;
        public static implicit operator pid_t(int data) => new() { Data = data };
    }

    // Typedef @ types.h:69:18 (/usr/include/x86_64-linux-gnu/sys/types.h)
    [StructLayout(LayoutKind.Explicit, Size = 4, Pack = 4)]
    public struct mode_t
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public __mode_t Data;

        public static implicit operator __mode_t(mode_t data) => data.Data;
        public static implicit operator mode_t(__mode_t data) => new() { Data = data };
    }

    // Typedef @ stdio.h:63:17 (/usr/include/stdio.h)
    [StructLayout(LayoutKind.Explicit, Size = 8, Pack = 8)]
    public struct off_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public __off_t Data;

        public static implicit operator __off_t(off_t data) => data.Data;
        public static implicit operator off_t(__off_t data) => new() { Data = data };
    }

    // Typedef @ types.h:79:17 (/usr/include/x86_64-linux-gnu/sys/types.h)
    [StructLayout(LayoutKind.Explicit, Size = 4, Pack = 4)]
    public struct uid_t
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public uint Data;

        public static implicit operator uint(uid_t data) => data.Data;
        public static implicit operator uid_t(uint data) => new() { Data = data };
    }

    // Typedef @ types.h:64:17 (/usr/include/x86_64-linux-gnu/sys/types.h)
    [StructLayout(LayoutKind.Explicit, Size = 4, Pack = 4)]
    public struct gid_t
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public uint Data;

        public static implicit operator uint(gid_t data) => data.Data;
        public static implicit operator gid_t(uint data) => new() { Data = data };
    }

    // Typedef @ in.h:119:18 (/usr/include/netinet/in.h)
    [StructLayout(LayoutKind.Explicit, Size = 2, Pack = 2)]
    public struct in_port_t
    {
        [FieldOffset(0)] // size = 2, padding = 0
        public ushort Data;

        public static implicit operator ushort(in_port_t data) => data.Data;
        public static implicit operator in_port_t(ushort data) => new() { Data = data };
    }

    // Typedef @ pthreadtypes.h:53:30 (/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h)
    [StructLayout(LayoutKind.Explicit, Size = 4, Pack = 4)]
    public struct pthread_once_t
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public int Data;

        public static implicit operator int(pthread_once_t data) => data.Data;
        public static implicit operator pthread_once_t(int data) => new() { Data = data };
    }

    // Typedef @ pthreadtypes.h:49:22 (/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h)
    [StructLayout(LayoutKind.Explicit, Size = 4, Pack = 4)]
    public struct pthread_key_t
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public uint Data;

        public static implicit operator uint(pthread_key_t data) => data.Data;
        public static implicit operator pthread_key_t(uint data) => new() { Data = data };
    }

    // Typedef @ pthreadtypes.h:27:27 (/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h)
    [StructLayout(LayoutKind.Explicit, Size = 8, Pack = 8)]
    public struct pthread_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public ulong Data;

        public static implicit operator ulong(pthread_t data) => data.Data;
        public static implicit operator pthread_t(ulong data) => new() { Data = data };
    }

    // Typedef @ termios.h:25:22 (/usr/include/x86_64-linux-gnu/bits/termios.h)
    [StructLayout(LayoutKind.Explicit, Size = 4, Pack = 4)]
    public struct tcflag_t
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public uint Data;

        public static implicit operator uint(tcflag_t data) => data.Data;
        public static implicit operator tcflag_t(uint data) => new() { Data = data };
    }

    // Typedef @ termios.h:23:23 (/usr/include/x86_64-linux-gnu/bits/termios.h)
    [StructLayout(LayoutKind.Explicit, Size = 1, Pack = 1)]
    public struct cc_t
    {
        [FieldOffset(0)] // size = 1, padding = 0
        public byte Data;

        public static implicit operator byte(cc_t data) => data.Data;
        public static implicit operator cc_t(byte data) => new() { Data = data };
    }

    // Typedef @ termios.h:24:22 (/usr/include/x86_64-linux-gnu/bits/termios.h)
    [StructLayout(LayoutKind.Explicit, Size = 4, Pack = 4)]
    public struct speed_t
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public uint Data;

        public static implicit operator uint(speed_t data) => data.Data;
        public static implicit operator speed_t(uint data) => new() { Data = data };
    }

    // Typedef @ types.h:150:26 (/usr/include/x86_64-linux-gnu/bits/types.h)
    [StructLayout(LayoutKind.Explicit, Size = 4, Pack = 4)]
    public struct __mode_t
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public uint Data;

        public static implicit operator uint(__mode_t data) => data.Data;
        public static implicit operator __mode_t(uint data) => new() { Data = data };
    }

    // Typedef @ types.h:152:25 (/usr/include/x86_64-linux-gnu/bits/types.h)
    [StructLayout(LayoutKind.Explicit, Size = 8, Pack = 8)]
    public struct __off_t
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public long Data;

        public static implicit operator long(__off_t data) => data.Data;
        public static implicit operator __off_t(long data) => new() { Data = data };
    }

    // Typedef @ in.h:30:18 (/usr/include/netinet/in.h)
    [StructLayout(LayoutKind.Explicit, Size = 4, Pack = 4)]
    public struct in_addr_t
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public uint Data;

        public static implicit operator uint(in_addr_t data) => data.Data;
        public static implicit operator in_addr_t(uint data) => new() { Data = data };
    }

    // Enum @ uv.h:256:3
    public enum uv_loop_option : int
    {
        UV_LOOP_BLOCK_SIGNAL = 0,
        UV_METRICS_IDLE_TIME = 1
    }

    // Enum @ uv.h:262:3
    public enum uv_run_mode : int
    {
        UV_RUN_DEFAULT = 0,
        UV_RUN_ONCE = 1,
        UV_RUN_NOWAIT = 2
    }

    // Enum @ uv.h:200:3
    public enum uv_handle_type : int
    {
        UV_UNKNOWN_HANDLE = 0,
        UV_ASYNC = 1,
        UV_CHECK = 2,
        UV_FS_EVENT = 3,
        UV_FS_POLL = 4,
        UV_HANDLE = 5,
        UV_IDLE = 6,
        UV_NAMED_PIPE = 7,
        UV_POLL = 8,
        UV_PREPARE = 9,
        UV_PROCESS = 10,
        UV_STREAM = 11,
        UV_TCP = 12,
        UV_TIMER = 13,
        UV_TTY = 14,
        UV_UDP = 15,
        UV_SIGNAL = 16,
        UV_FILE = 17,
        UV_HANDLE_TYPE_MAX = 18
    }

    // Enum @ uv.h:209:3
    public enum uv_req_type : int
    {
        UV_UNKNOWN_REQ = 0,
        UV_REQ = 1,
        UV_CONNECT = 2,
        UV_WRITE = 3,
        UV_SHUTDOWN = 4,
        UV_UDP_SEND = 5,
        UV_FS = 6,
        UV_WORK = 7,
        UV_GETADDRINFO = 8,
        UV_GETNAMEINFO = 9,
        UV_RANDOM = 10,
        UV_REQ_TYPE_MAX = 11
    }

    // Enum @ uv.h:389:3
    public enum uv_membership : int
    {
        UV_LEAVE_GROUP = 0,
        UV_JOIN_GROUP = 1
    }

    // Enum @ uv.h:748:3
    public enum uv_tty_mode_t : int
    {
        UV_TTY_MODE_NORMAL = 0,
        UV_TTY_MODE_RAW = 1,
        UV_TTY_MODE_IO = 2
    }

    // Enum @ uv.h:760:3
    public enum uv_tty_vtermstate_t : int
    {
        UV_TTY_SUPPORTED = 0,
        UV_TTY_UNSUPPORTED = 1
    }

    // Enum @ uv.h:1320:3
    public enum uv_fs_type : int
    {
        UV_FS_UNKNOWN = -1,
        UV_FS_CUSTOM = 0,
        UV_FS_OPEN = 1,
        UV_FS_CLOSE = 2,
        UV_FS_READ = 3,
        UV_FS_WRITE = 4,
        UV_FS_SENDFILE = 5,
        UV_FS_STAT = 6,
        UV_FS_LSTAT = 7,
        UV_FS_FSTAT = 8,
        UV_FS_FTRUNCATE = 9,
        UV_FS_UTIME = 10,
        UV_FS_FUTIME = 11,
        UV_FS_ACCESS = 12,
        UV_FS_CHMOD = 13,
        UV_FS_FCHMOD = 14,
        UV_FS_FSYNC = 15,
        UV_FS_FDATASYNC = 16,
        UV_FS_UNLINK = 17,
        UV_FS_RMDIR = 18,
        UV_FS_MKDIR = 19,
        UV_FS_MKDTEMP = 20,
        UV_FS_RENAME = 21,
        UV_FS_SCANDIR = 22,
        UV_FS_LINK = 23,
        UV_FS_SYMLINK = 24,
        UV_FS_READLINK = 25,
        UV_FS_CHOWN = 26,
        UV_FS_FCHOWN = 27,
        UV_FS_REALPATH = 28,
        UV_FS_COPYFILE = 29,
        UV_FS_LCHOWN = 30,
        UV_FS_OPENDIR = 31,
        UV_FS_READDIR = 32,
        UV_FS_CLOSEDIR = 33,
        UV_FS_STATFS = 34,
        UV_FS_MKSTEMP = 35,
        UV_FS_LUTIME = 36
    }

    // Enum @ uv.h:1172:3
    public enum uv_dirent_type_t : int
    {
        UV_DIRENT_UNKNOWN = 0,
        UV_DIRENT_FILE = 1,
        UV_DIRENT_DIR = 2,
        UV_DIRENT_LINK = 3,
        UV_DIRENT_FIFO = 4,
        UV_DIRENT_SOCKET = 5,
        UV_DIRENT_CHAR = 6,
        UV_DIRENT_BLOCK = 7
    }

    // Enum @ uv.h:964:3
    public enum uv_stdio_flags : int
    {
        UV_IGNORE = 0,
        UV_CREATE_PIPE = 1,
        UV_INHERIT_FD = 2,
        UV_INHERIT_STREAM = 4,
        UV_READABLE_PIPE = 16,
        UV_WRITABLE_PIPE = 32,
        UV_NONBLOCK_PIPE = 64,
        UV_OVERLAPPED_PIPE = 64
    }

    // Pseudo enum 'uv_errno_t' @ uv.h:186:9
    public const int UV_E2BIG = -7;
    public const int UV_EACCES = -13;
    public const int UV_EADDRINUSE = -98;
    public const int UV_EADDRNOTAVAIL = -99;
    public const int UV_EAFNOSUPPORT = -97;
    public const int UV_EAGAIN = -11;
    public const int UV_EAI_ADDRFAMILY = -3000;
    public const int UV_EAI_AGAIN = -3001;
    public const int UV_EAI_BADFLAGS = -3002;
    public const int UV_EAI_BADHINTS = -3013;
    public const int UV_EAI_CANCELED = -3003;
    public const int UV_EAI_FAIL = -3004;
    public const int UV_EAI_FAMILY = -3005;
    public const int UV_EAI_MEMORY = -3006;
    public const int UV_EAI_NODATA = -3007;
    public const int UV_EAI_NONAME = -3008;
    public const int UV_EAI_OVERFLOW = -3009;
    public const int UV_EAI_PROTOCOL = -3014;
    public const int UV_EAI_SERVICE = -3010;
    public const int UV_EAI_SOCKTYPE = -3011;
    public const int UV_EALREADY = -114;
    public const int UV_EBADF = -9;
    public const int UV_EBUSY = -16;
    public const int UV_ECANCELED = -125;
    public const int UV_ECHARSET = -4080;
    public const int UV_ECONNABORTED = -103;
    public const int UV_ECONNREFUSED = -111;
    public const int UV_ECONNRESET = -104;
    public const int UV_EDESTADDRREQ = -89;
    public const int UV_EEXIST = -17;
    public const int UV_EFAULT = -14;
    public const int UV_EFBIG = -27;
    public const int UV_EHOSTUNREACH = -113;
    public const int UV_EINTR = -4;
    public const int UV_EINVAL = -22;
    public const int UV_EIO = -5;
    public const int UV_EISCONN = -106;
    public const int UV_EISDIR = -21;
    public const int UV_ELOOP = -40;
    public const int UV_EMFILE = -24;
    public const int UV_EMSGSIZE = -90;
    public const int UV_ENAMETOOLONG = -36;
    public const int UV_ENETDOWN = -100;
    public const int UV_ENETUNREACH = -101;
    public const int UV_ENFILE = -23;
    public const int UV_ENOBUFS = -105;
    public const int UV_ENODEV = -19;
    public const int UV_ENOENT = -2;
    public const int UV_ENOMEM = -12;
    public const int UV_ENONET = -64;
    public const int UV_ENOPROTOOPT = -92;
    public const int UV_ENOSPC = -28;
    public const int UV_ENOSYS = -38;
    public const int UV_ENOTCONN = -107;
    public const int UV_ENOTDIR = -20;
    public const int UV_ENOTEMPTY = -39;
    public const int UV_ENOTSOCK = -88;
    public const int UV_ENOTSUP = -95;
    public const int UV_EOVERFLOW = -75;
    public const int UV_EPERM = -1;
    public const int UV_EPIPE = -32;
    public const int UV_EPROTO = -71;
    public const int UV_EPROTONOSUPPORT = -93;
    public const int UV_EPROTOTYPE = -91;
    public const int UV_ERANGE = -34;
    public const int UV_EROFS = -30;
    public const int UV_ESHUTDOWN = -108;
    public const int UV_ESPIPE = -29;
    public const int UV_ESRCH = -3;
    public const int UV_ETIMEDOUT = -110;
    public const int UV_ETXTBSY = -26;
    public const int UV_EXDEV = -18;
    public const int UV_UNKNOWN = -4094;
    public const int UV_EOF = -4095;
    public const int UV_ENXIO = -6;
    public const int UV_EMLINK = -31;
    public const int UV_EHOSTDOWN = -112;
    public const int UV_EREMOTEIO = -121;
    public const int UV_ENOTTY = -25;
    public const int UV_EFTYPE = -4028;
    public const int UV_EILSEQ = -84;
    public const int UV_ESOCKTNOSUPPORT = -94;
    public const int UV_ERRNO_MAX = -4096;

    // Pseudo enum 'uv_tcp_flags' @ uv.h:576:6
    public const int UV_TCP_IPV6ONLY = 1;

    // Pseudo enum 'uv_udp_flags' @ uv.h:609:6
    public const int UV_UDP_IPV6ONLY = 1;
    public const int UV_UDP_PARTIAL = 2;
    public const int UV_UDP_REUSEADDR = 4;
    public const int UV_UDP_MMSG_CHUNK = 8;
    public const int UV_UDP_MMSG_FREE = 16;
    public const int UV_UDP_LINUX_RECVERR = 32;
    public const int UV_UDP_RECVMMSG = 256;

    // Pseudo enum 'uv_poll_event' @ uv.h:820:6
    public const int UV_READABLE = 1;
    public const int UV_WRITABLE = 2;
    public const int UV_DISCONNECT = 4;
    public const int UV_PRIORITIZED = 8;

    // Pseudo enum 'uv_process_flags' @ uv.h:1023:6
    public const int UV_PROCESS_SETUID = 1;
    public const int UV_PROCESS_SETGID = 2;
    public const int UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS = 4;
    public const int UV_PROCESS_DETACHED = 8;
    public const int UV_PROCESS_WINDOWS_HIDE = 16;
    public const int UV_PROCESS_WINDOWS_HIDE_CONSOLE = 32;
    public const int UV_PROCESS_WINDOWS_HIDE_GUI = 64;

    // Pseudo enum 'uv_fs_event' @ uv.h:1564:6
    public const int UV_RENAME = 1;
    public const int UV_CHANGE = 2;

    // Pseudo enum 'uv_fs_event_flags' @ uv.h:1620:6
    public const int UV_FS_EVENT_WATCH_ENTRY = 1;
    public const int UV_FS_EVENT_STAT = 2;
    public const int UV_FS_EVENT_RECURSIVE = 4;

    // Pseudo enum 'uv_thread_create_flags' @ uv.h:1772:9
    public const int UV_THREAD_NO_FLAGS = 0;
    public const int UV_THREAD_HAS_STACK_SIZE = 1;

    // MacroDefinition @ errno.h:32:9 (uv/errno.h)
    public const int UV__EOF = -4095;

    // MacroDefinition @ errno.h:33:9 (uv/errno.h)
    public const int UV__UNKNOWN = -4094;

    // MacroDefinition @ errno.h:35:9 (uv/errno.h)
    public const int UV__EAI_ADDRFAMILY = -3000;

    // MacroDefinition @ errno.h:36:9 (uv/errno.h)
    public const int UV__EAI_AGAIN = -3001;

    // MacroDefinition @ errno.h:37:9 (uv/errno.h)
    public const int UV__EAI_BADFLAGS = -3002;

    // MacroDefinition @ errno.h:38:9 (uv/errno.h)
    public const int UV__EAI_CANCELED = -3003;

    // MacroDefinition @ errno.h:39:9 (uv/errno.h)
    public const int UV__EAI_FAIL = -3004;

    // MacroDefinition @ errno.h:40:9 (uv/errno.h)
    public const int UV__EAI_FAMILY = -3005;

    // MacroDefinition @ errno.h:41:9 (uv/errno.h)
    public const int UV__EAI_MEMORY = -3006;

    // MacroDefinition @ errno.h:42:9 (uv/errno.h)
    public const int UV__EAI_NODATA = -3007;

    // MacroDefinition @ errno.h:43:9 (uv/errno.h)
    public const int UV__EAI_NONAME = -3008;

    // MacroDefinition @ errno.h:44:9 (uv/errno.h)
    public const int UV__EAI_OVERFLOW = -3009;

    // MacroDefinition @ errno.h:45:9 (uv/errno.h)
    public const int UV__EAI_SERVICE = -3010;

    // MacroDefinition @ errno.h:46:9 (uv/errno.h)
    public const int UV__EAI_SOCKTYPE = -3011;

    // MacroDefinition @ errno.h:47:9 (uv/errno.h)
    public const int UV__EAI_BADHINTS = -3013;

    // MacroDefinition @ errno.h:48:9 (uv/errno.h)
    public const int UV__EAI_PROTOCOL = -3014;

    // MacroDefinition @ errno.h:116:10 (uv/errno.h)
    public const int UV__ECHARSET = -4080;

    // MacroDefinition @ errno.h:439:10 (uv/errno.h)
    public const int UV__EFTYPE = -4028;

    // MacroDefinition @ version.h:33:9 (uv/version.h)
    public const int UV_VERSION_MAJOR = 1;

    // MacroDefinition @ version.h:34:9 (uv/version.h)
    public const int UV_VERSION_MINOR = 42;

    // MacroDefinition @ version.h:35:9 (uv/version.h)
    public const int UV_VERSION_PATCH = 1;

    // MacroDefinition @ version.h:36:9 (uv/version.h)
    public const int UV_VERSION_IS_RELEASE = 0;

    // MacroDefinition @ version.h:37:9 (uv/version.h)
    public const string UV_VERSION_SUFFIX = "dev";

    // MacroDefinition @ version.h:39:9 (uv/version.h)
    public const int UV_VERSION_HEX = (UV_VERSION_MAJOR << 16) | (UV_VERSION_MINOR << 8) | (UV_VERSION_PATCH);

    // MacroDefinition @ unix.h:420:10 (uv/unix.h)
    public const int UV_FS_O_DIRECT = 0x04000;

    // MacroDefinition @ unix.h:445:10 (uv/unix.h)
    public const int UV_FS_O_EXLOCK = 0;

    // MacroDefinition @ unix.h:450:10 (uv/unix.h)
    public const int UV_FS_O_NOATIME = 0;

    // MacroDefinition @ unix.h:480:10 (uv/unix.h)
    public const int UV_FS_O_SYMLINK = 0;

    // MacroDefinition @ unix.h:499:9 (uv/unix.h)
    public const int UV_FS_O_FILEMAP = 0;

    // MacroDefinition @ unix.h:500:9 (uv/unix.h)
    public const int UV_FS_O_RANDOM = 0;

    // MacroDefinition @ unix.h:501:9 (uv/unix.h)
    public const int UV_FS_O_SHORT_LIVED = 0;

    // MacroDefinition @ unix.h:502:9 (uv/unix.h)
    public const int UV_FS_O_SEQUENTIAL = 0;

    // MacroDefinition @ unix.h:503:9 (uv/unix.h)
    public const int UV_FS_O_TEMPORARY = 0;

    // MacroDefinition @ uv.h:1234:10
    public const int UV_PRIORITY_LOW = 19;

    // MacroDefinition @ uv.h:1235:10
    public const int UV_PRIORITY_BELOW_NORMAL = 10;

    // MacroDefinition @ uv.h:1236:10
    public const int UV_PRIORITY_NORMAL = 0;

    // MacroDefinition @ uv.h:1237:10
    public const int UV_PRIORITY_ABOVE_NORMAL = -7;

    // MacroDefinition @ uv.h:1238:10
    public const int UV_PRIORITY_HIGH = -14;

    // MacroDefinition @ uv.h:1239:10
    public const int UV_PRIORITY_HIGHEST = -20;

    // MacroDefinition @ uv.h:1382:9
    public const int UV_FS_COPYFILE_EXCL = 0x0001;

    // MacroDefinition @ uv.h:1388:9
    public const int UV_FS_COPYFILE_FICLONE = 0x0002;

    // MacroDefinition @ uv.h:1394:9
    public const int UV_FS_COPYFILE_FICLONE_FORCE = 0x0004;

    // MacroDefinition @ uv.h:1513:9
    public const int UV_FS_SYMLINK_DIR = 0x0001;

    // MacroDefinition @ uv.h:1519:9
    public const int UV_FS_SYMLINK_JUNCTION = 0x0002;

    // MacroDefinition @ uv.h:1693:10
    public const int UV_IF_NAMESIZE = 16 + 1;

    /// <summary>
    ///     A boolean value type with the same memory layout as a <see cref="byte" /> in both managed and unmanaged contexts;
    ///     equivalent to a standard bool found in C/C++/ObjC where <c>0</c> is <c>false</c> and any other value is
    ///     <c>true</c>.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public readonly struct CBool : IEquatable<CBool>
    {
        private readonly byte _value;

        private CBool(bool value)
        {
            _value = Convert.ToByte(value);
        }

        /// <summary>
        ///     Converts the specified <see cref="bool" /> to a <see cref="CBool" />.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>A <see cref="CBool" />.</returns>
        public static implicit operator CBool(bool value)
        {
            return CBool.FromBoolean(value);
        }

        /// <summary>
        ///     Converts the specified <see cref="bool" /> to a <see cref="CBool" />.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>A <see cref="CBool" />.</returns>
        public static CBool FromBoolean(bool value)
        {
            return new CBool(value);
        }

        /// <summary>
        ///     Converts the specified <see cref="CBool" /> to a <see cref="bool" />.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>A <see cref="bool" />.</returns>
        public static implicit operator bool(CBool value)
        {
            return ToBoolean(value);
        }

        /// <summary>
        ///     Converts the specified <see cref="CBool" /> to a <see cref="bool" />.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>A <see cref="bool" />.</returns>
        public static bool ToBoolean(CBool value)
        {
            return Convert.ToBoolean(value);
        }

        /// <inheritdoc />
        public override string ToString()
        {
            return ToBoolean(this).ToString();
        }

        /// <inheritdoc />
        public override bool Equals(object? obj)
        {
            return obj is CBool b && Equals(b);
        }

        /// <inheritdoc />
        public bool Equals(CBool other)
        {
            return _value == other._value;
        }

        /// <inheritdoc />
        public override int GetHashCode()
        {
            return _value.GetHashCode();
        }

        /// <summary>
        ///     Returns a value that indicates whether two specified <see cref="CBool" /> structures are equal.
        /// </summary>
        /// <param name="left">The first <see cref="CBool" /> to compare.</param>
        /// <param name="right">The second <see cref="CBool" /> to compare.</param>
        /// <returns><c>true</c> if <paramref name="left"/> and <paramref name="right"/> are equal; otherwise, <c>false</c>.</returns>
        public static bool operator ==(CBool left, CBool right)
        {
            return left._value == right._value;
        }

        /// <summary>
        ///     Returns a value that indicates whether two specified <see cref="CBool" /> structures are not equal.
        /// </summary>
        /// <param name="left">The first <see cref="CBool" /> to compare.</param>
        /// <param name="right">The second <see cref="CBool" /> to compare.</param>
        /// <returns><c>true</c> if <paramref name="left"/> and <paramref name="right"/> are not equal; otherwise, <c>false</c>.</returns>
        public static bool operator !=(CBool left, CBool right)
        {
            return !(left == right);
        }

        /// <summary>
        ///     Returns a value that indicates whether two specified <see cref="CBool" /> structures are equal.
        /// </summary>
        /// <param name="left">The first <see cref="CBool" /> to compare.</param>
        /// <param name="right">The second <see cref="CBool" /> to compare.</param>
        /// <returns><c>true</c> if <paramref name="left"/> and <paramref name="right"/> are equal; otherwise, <c>false</c>.</returns>
        public static bool Equals(CBool left, CBool right)
        {
            return left._value == right._value;
        }
    }

    /// <summary>
    ///     A value type with the same memory layout as a <see cref="byte" /> in a managed context and <c>char</c> in
    ///     an unmanaged context.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public readonly struct CChar : IEquatable<byte>, IEquatable<CChar>
    {
        private readonly byte _value;

        private CChar(byte value)
        {
            _value = Convert.ToByte(value);
        }

        /// <summary>
        ///     Converts the specified <see cref="byte" /> to a <see cref="CChar" />.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>A <see cref="CChar" />.</returns>
        public static implicit operator CChar(byte value)
        {
            return FromByte(value);
        }

        /// <summary>
        ///     Converts the specified <see cref="byte" /> to a <see cref="CChar" />.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>A <see cref="CChar" />.</returns>
        public static CChar FromByte(byte value)
        {
            return new CChar(value);
        }

        /// <summary>
        ///     Converts the specified <see cref="CChar" /> to a <see cref="byte" />.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>A <see cref="byte" />.</returns>
        public static implicit operator byte(CChar value)
        {
            return ToByte(value);
        }

        /// <summary>
        ///     Converts the specified <see cref="CChar" /> to a <see cref="byte" />.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>A <see cref="byte" />.</returns>
        public static byte ToByte(CChar value)
        {
            return value._value;
        }

        /// <inheritdoc />
        public override string ToString()
        {
            return _value.ToString(CultureInfo.InvariantCulture);
        }

        /// <inheritdoc />
        public override bool Equals(object? obj)
        {
            return obj is CChar value && Equals(value);
        }

        /// <inheritdoc />
        public bool Equals(byte other)
        {
            return _value == other;
        }

        /// <inheritdoc />
        public bool Equals(CChar other)
        {
            return _value == other._value;
        }

        /// <inheritdoc />
        public override int GetHashCode()
        {
            return _value.GetHashCode();
        }

        /// <summary>
        ///     Returns a value that indicates whether two specified <see cref="CChar" /> structures are equal.
        /// </summary>
        /// <param name="left">The first <see cref="CChar" /> to compare.</param>
        /// <param name="right">The second <see cref="CChar" /> to compare.</param>
        /// <returns><c>true</c> if <paramref name="left"/> and <paramref name="right"/> are equal; otherwise, <c>false</c>.</returns>
        public static bool operator ==(CChar left, CChar right)
        {
            return left._value == right._value;
        }

        /// <summary>
        ///     Returns a value that indicates whether two specified <see cref="CChar" /> structures are not equal.
        /// </summary>
        /// <param name="left">The first <see cref="CChar" /> to compare.</param>
        /// <param name="right">The second <see cref="CChar" /> to compare.</param>
        /// <returns><c>true</c> if <paramref name="left"/> and <paramref name="right"/> are not equal; otherwise, <c>false</c>.</returns>
        public static bool operator !=(CChar left, CChar right)
        {
            return !(left == right);
        }

        /// <summary>
        ///     Returns a value that indicates whether two specified <see cref="CChar" /> structures are equal.
        /// </summary>
        /// <param name="left">The first <see cref="CChar" /> to compare.</param>
        /// <param name="right">The second <see cref="CChar" /> to compare.</param>
        /// <returns><c>true</c> if <paramref name="left"/> and <paramref name="right"/> are equal; otherwise, <c>false</c>.</returns>
        public static bool Equals(CChar left, CChar right)
        {
            return left._value == right._value;
        }
    }

    /// <summary>
    ///     A value type with the memory layout of a <c>wchar_t</c> in an unmanaged context. The memory layout in a
    ///     managed context depends on the operating system or otherwise on preprocessor directives defines.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public readonly struct CCharWide : IEquatable<CCharWide>
    {
#if SIZEOF_WCHAR_T_1
    private readonly byte _value;
#elif SIZEOF_WCHAR_T_2
    private readonly ushort _value;
#elif SIZEOF_WCHAR_T_4
    private readonly uint _value;
#else
        private readonly ushort _value;
#endif

        private CCharWide(byte value)
        {
#if SIZEOF_WCHAR_T_1
        _value = Convert.ToByte(value);
#elif SIZEOF_WCHAR_T_2
        _value = Convert.ToUInt16(value);
#elif SIZEOF_WCHAR_T_4
        _value = Convert.ToUInt32(value);
#else
            _value = Convert.ToUInt16(value);
#endif
        }

        /// <inheritdoc />
        public override string ToString()
        {
            return _value.ToString(CultureInfo.InvariantCulture);
        }

        /// <inheritdoc />
        public override bool Equals(object? obj)
        {
            return obj is CCharWide value && Equals(value);
        }

        /// <inheritdoc />
        public bool Equals(CCharWide other)
        {
            return _value == other._value;
        }

        /// <inheritdoc />
        public override int GetHashCode()
        {
            return _value.GetHashCode();
        }

        /// <summary>
        ///     Returns a value that indicates whether two specified <see cref="CCharWide" /> structures are equal.
        /// </summary>
        /// <param name="left">The first <see cref="CCharWide" /> to compare.</param>
        /// <param name="right">The second <see cref="CCharWide" /> to compare.</param>
        /// <returns><c>true</c> if <paramref name="left"/> and <paramref name="right"/> are equal; otherwise, <c>false</c>.</returns>
        public static bool operator ==(CCharWide left, CCharWide right)
        {
            return left._value == right._value;
        }

        /// <summary>
        ///     Returns a value that indicates whether two specified <see cref="CCharWide" /> structures are not equal.
        /// </summary>
        /// <param name="left">The first <see cref="CCharWide" /> to compare.</param>
        /// <param name="right">The second <see cref="CCharWide" /> to compare.</param>
        /// <returns><c>true</c> if <paramref name="left"/> and <paramref name="right"/> are not equal; otherwise, <c>false</c>.</returns>
        public static bool operator !=(CCharWide left, CCharWide right)
        {
            return !(left == right);
        }

        /// <summary>
        ///     Returns a value that indicates whether two specified <see cref="CCharWide" /> structures are equal.
        /// </summary>
        /// <param name="left">The first <see cref="CCharWide" /> to compare.</param>
        /// <param name="right">The second <see cref="CCharWide" /> to compare.</param>
        /// <returns><c>true</c> if <paramref name="left"/> and <paramref name="right"/> are equal; otherwise, <c>false</c>.</returns>
        public static bool Equals(CCharWide left, CCharWide right)
        {
            return left._value == right._value;
        }
    }

    /// <summary>
    ///     A pointer value type of bytes that represent a string; the C type `char*`.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public readonly unsafe struct CString : IEquatable<CString>
    {
        internal readonly nint _pointer;

        /// <summary>
        ///     Gets a value indicating whether this <see cref="CString" /> is a null pointer.
        /// </summary>
        public bool IsNull => _pointer == 0;

        /// <summary>
        ///     Initializes a new instance of the <see cref="CString" /> struct.
        /// </summary>
        /// <param name="value">The pointer value.</param>
        public CString(byte* value)
        {
            _pointer = (nint)value;
        }

        /// <summary>
        ///     Initializes a new instance of the <see cref="CString" /> struct.
        /// </summary>
        /// <param name="value">The pointer value.</param>
        public CString(nint value)
        {
            _pointer = value;
        }

        /// <summary>
        ///     Initializes a new instance of the <see cref="CString" /> struct.
        /// </summary>
        /// <param name="s">The string value.</param>
        public CString(string s)
        {
            _pointer = CStrings.CString(s);
        }

        /// <summary>
        ///     Performs an explicit conversion from a <see cref="IntPtr" /> to a <see cref="CString" />.
        /// </summary>
        /// <param name="value">The pointer value.</param>
        /// <returns>
        ///     The resulting <see cref="CString" />.
        /// </returns>
        public static explicit operator CString(nint value)
        {
            return FromIntPtr(value);
        }

        /// <summary>
        ///     Performs an explicit conversion from a <see cref="IntPtr" /> to a <see cref="CString" />.
        /// </summary>
        /// <param name="value">The pointer value.</param>
        /// <returns>
        ///     The resulting <see cref="CString" />.
        /// </returns>
        public static CString FromIntPtr(nint value)
        {
            return new(value);
        }

        /// <summary>
        ///     Performs an implicit conversion from a byte pointer to a <see cref="CString" />.
        /// </summary>
        /// <param name="value">The pointer value.</param>
        /// <returns>
        ///     The resulting <see cref="CString" />.
        /// </returns>
        public static implicit operator CString(byte* value)
        {
            return From(value);
        }

        /// <summary>
        ///     Performs an implicit conversion from a byte pointer to a <see cref="CString" />.
        /// </summary>
        /// <param name="value">The pointer value.</param>
        /// <returns>
        ///     The resulting <see cref="CString" />.
        /// </returns>
        public static CString From(byte* value)
        {
            return new((nint)value);
        }

        /// <summary>
        ///     Performs an implicit conversion from a <see cref="CString" /> to a <see cref="IntPtr" />.
        /// </summary>
        /// <param name="value">The pointer.</param>
        /// <returns>
        ///     The resulting <see cref="IntPtr" />.
        /// </returns>
        public static implicit operator nint(CString value)
        {
            return value._pointer;
        }

        /// <summary>
        ///     Performs an implicit conversion from a <see cref="CString" /> to a <see cref="IntPtr" />.
        /// </summary>
        /// <param name="value">The pointer.</param>
        /// <returns>
        ///     The resulting <see cref="IntPtr" />.
        /// </returns>
        public static nint ToIntPtr(CString value)
        {
            return value._pointer;
        }

        /// <summary>
        ///     Performs an implicit conversion from a <see cref="CString" /> to a <see cref="string" />.
        /// </summary>
        /// <param name="value">The <see cref="CString" />.</param>
        /// <returns>
        ///     The resulting <see cref="string" />.
        /// </returns>
        public static implicit operator string(CString value)
        {
            return ToString(value);
        }

        /// <summary>
        ///     Performs an implicit conversion from a <see cref="CString" /> to a <see cref="string" />.
        /// </summary>
        /// <param name="value">The <see cref="CString" />.</param>
        /// <returns>
        ///     The resulting <see cref="string" />.
        /// </returns>
        public static string ToString(CString value)
        {
            return CStrings.String(value);
        }

        /// <summary>
        ///     Performs an implicit conversion from a <see cref="string" /> to a <see cref="CString" />.
        /// </summary>
        /// <param name="s">The <see cref="string" />.</param>
        /// <returns>
        ///     The resulting <see cref="CString" />.
        /// </returns>
        public static implicit operator CString(string s)
        {
            return FromString(s);
        }

        /// <summary>
        ///     Performs an implicit conversion from a <see cref="string" /> to a <see cref="CString" />.
        /// </summary>
        /// <param name="s">The <see cref="string" />.</param>
        /// <returns>
        ///     The resulting <see cref="CString" />.
        /// </returns>
        public static CString FromString(string s)
        {
            return CStrings.CString(s);
        }

        /// <inheritdoc />
        public override string ToString()
        {
            return CStrings.String(this);
        }

        /// <inheritdoc />
        public override bool Equals(object? obj)
        {
            return obj is CString value && Equals(value);
        }

        /// <inheritdoc />
        public bool Equals(CString other)
        {
            return _pointer == other._pointer;
        }

        /// <inheritdoc />
        public override int GetHashCode()
        {
            return _pointer.GetHashCode();
        }

        /// <summary>
        ///     Returns a value that indicates whether two specified <see cref="CString" /> structures are equal.
        /// </summary>
        /// <param name="left">The first <see cref="CString" /> to compare.</param>
        /// <param name="right">The second <see cref="CString" /> to compare.</param>
        /// <returns><c>true</c> if <paramref name="left"/> and <paramref name="right"/> are equal; otherwise, <c>false</c>.</returns>
        public static bool operator ==(CString left, CString right)
        {
            return left._pointer == right._pointer;
        }

        /// <summary>
        ///     Returns a value that indicates whether two specified <see cref="CBool" /> structures are not equal.
        /// </summary>
        /// <param name="left">The first <see cref="CString" /> to compare.</param>
        /// <param name="right">The second <see cref="CString" /> to compare.</param>
        /// <returns><c>true</c> if <paramref name="left"/> and <paramref name="right"/> are not equal; otherwise, <c>false</c>.</returns>
        public static bool operator !=(CString left, CString right)
        {
            return !(left == right);
        }

        /// <summary>
        ///     Returns a value that indicates whether two specified <see cref="CString" /> structures are equal.
        /// </summary>
        /// <param name="left">The first <see cref="CString" /> to compare.</param>
        /// <param name="right">The second <see cref="CString" /> to compare.</param>
        /// <returns><c>true</c> if <paramref name="left"/> and <paramref name="right"/> are equal; otherwise, <c>false</c>.</returns>
        public static bool Equals(CString left, CString right)
        {
            return left._pointer == right._pointer;
        }
    }

    /// <summary>
    ///     The collection of utility methods for interoperability with C style strings in C#.
    /// </summary>
    public static unsafe class CStrings
    {
        private static readonly Dictionary<uint, CString> StringHashesToPointers = new();
        private static readonly Dictionary<nint, string> PointersToStrings = new();
        private static readonly Dictionary<uint, CStringWide> StringHashesToPointersWide = new();
        private static readonly Dictionary<nint, string> PointersToStringsWide = new();

        // NOTE: On portability, technically `char` in C could be signed or unsigned depending on the computer architecture,
        //  resulting in technically two different type bindings when transpiling C headers to C#. However, to make peace
        //  with the world, I settle on a compromise:
        //      `CString` is `char*`. When exposing public functions of ANSI/UTF8 strings in C#, you should only care about
        //      `char*` as a single "thing" not about it's parts "char" and "*".

        /// <summary>
        ///     Converts a C style string (ANSI or UTF-8) of type `char` (one dimensional byte array
        ///     terminated by a <c>0x0</c>) to a UTF-16 <see cref="string" /> by allocating and copying if not already cached.
        /// </summary>
        /// <param name="value">A pointer to the C string.</param>
        /// <returns>A <see cref="string" /> equivalent of <paramref name="value" />.</returns>
        public static string String(CString value)
        {
            if (value.IsNull)
            {
                return string.Empty;
            }

            if (PointersToStrings.TryGetValue(value._pointer, out var result))
            {
                return result;
            }

            var hash = Djb2((byte*)value._pointer);
            if (StringHashesToPointers.TryGetValue(hash, out var pointer2))
            {
                result = PointersToStrings[pointer2._pointer];
                return result;
            }

            // calls ASM/C/C++ functions to calculate length and then "FastAllocate" the string with the GC
            // https://mattwarren.org/2016/05/31/Strings-and-the-CLR-a-Special-Relationship/
            result = Marshal.PtrToStringAnsi(value._pointer);

            if (string.IsNullOrEmpty(result))
            {
                return string.Empty;
            }

            StringHashesToPointers.Add(hash, value);
            PointersToStrings.Add(value._pointer, result);

            return result;
        }

        /// <summary>
        ///     Converts a C style string (unicode) of type `wchar_t` (one dimensional ushort array
        ///     terminated by a <c>0x0</c>) to a UTF-16 <see cref="string" /> by allocating and copying if not already cached.
        /// </summary>
        /// <param name="value">A pointer to the C string.</param>
        /// <returns>A <see cref="string" /> equivalent of <paramref name="value" />.</returns>
        public static string StringWide(CStringWide value)
        {
            if (value.IsNull)
            {
                return string.Empty;
            }

            if (PointersToStringsWide.TryGetValue(value._pointer, out var result))
            {
                return result;
            }

            var hash = Djb2((byte*)value._pointer);
            if (StringHashesToPointersWide.TryGetValue(hash, out var pointer2))
            {
                result = PointersToStringsWide[pointer2._pointer];
                return result;
            }

            // calls ASM/C/C++ functions to calculate length and then "FastAllocate" the string with the GC
            // https://mattwarren.org/2016/05/31/Strings-and-the-CLR-a-Special-Relationship/
            result = Marshal.PtrToStringUni(pointer2._pointer);

            if (string.IsNullOrEmpty(result))
            {
                return string.Empty;
            }

            StringHashesToPointersWide.Add(hash, value);
            PointersToStringsWide.Add(value._pointer, result);

            return result;
        }

        /// <summary>
        ///     Converts a UTF-16 <see cref="string" /> to a C style string (one dimensional byte array terminated by a
        ///     <c>0x0</c>) by allocating and copying if not already cached.
        /// </summary>
        /// <param name="str">The <see cref="string" />.</param>
        /// <returns>A C string pointer.</returns>
        public static CString CString(string str)
        {
            var hash = Djb2(str);
            if (StringHashesToPointers.TryGetValue(hash, out var r))
            {
                return r;
            }

            // ReSharper disable once JoinDeclarationAndInitializer
            var pointer = Marshal.StringToHGlobalAnsi(str);
            StringHashesToPointers.Add(hash, new CString(pointer));
            PointersToStrings.Add(pointer, str);

            return new CString(pointer);
        }

        /// <summary>
        ///     Converts a C string pointer (one dimensional byte array terminated by a
        ///     <c>0x0</c>) for a specified <see cref="string" /> by allocating and copying if not already cached.
        /// </summary>
        /// <param name="str">The <see cref="string" />.</param>
        /// <returns>A C string pointer.</returns>
        public static CStringWide CStringWide(string str)
        {
            var hash = Djb2(str);
            if (StringHashesToPointersWide.TryGetValue(hash, out var r))
            {
                return r;
            }

            // ReSharper disable once JoinDeclarationAndInitializer
            var pointer = Marshal.StringToHGlobalUni(str);
            StringHashesToPointersWide.Add(hash, new CStringWide(pointer));
            PointersToStringsWide.Add(pointer, str);

            return new CStringWide(pointer);
        }

        /// <summary>
        ///     Converts an array of strings to an array of C strings of type `char` (multi-dimensional array of one
        ///     dimensional byte arrays each terminated by a <c>0x0</c>) by allocating and copying if not already cached.
        /// </summary>
        /// <remarks>
        ///     <para>Calls <see cref="CString" />.</para>
        /// </remarks>
        /// <param name="values">The strings.</param>
        /// <returns>An array pointer of C string pointers. You are responsible for freeing the returned pointer.</returns>
        public static CString* CStringArray(ReadOnlySpan<string> values)
        {
            var pointerSize = IntPtr.Size;
            var result = (CString*)Marshal.AllocHGlobal(pointerSize * values.Length);
            for (var i = 0; i < values.Length; ++i)
            {
                var @string = values[i];
                var cString = CString(@string);
                result[i] = cString;
            }

            return result;
        }

        /// <summary>
        ///     Converts an array of strings to an array of C strings of type `wchar_t` (multi-dimensional array of one
        ///     dimensional ushort arrays each terminated by a <c>0x0</c>) by allocating and copying if not already cached.
        /// </summary>
        /// <remarks>
        ///     <para>Calls <see cref="CString" />.</para>
        /// </remarks>
        /// <param name="values">The strings.</param>
        /// <returns>An array pointer of C string pointers. You are responsible for freeing the returned pointer.</returns>
        public static CStringWide* CStringWideArray(ReadOnlySpan<string> values)
        {
            var pointerSize = IntPtr.Size;
            var result = (CStringWide*)Marshal.AllocHGlobal(pointerSize * values.Length);
            for (var i = 0; i < values.Length; ++i)
            {
                var @string = values[i];
                var cString = CStringWide(@string);
                result[i] = cString;
            }

            return result;
        }

        /// <summary>
        ///     Frees the memory for all previously allocated C strings and releases references to all <see cref="string" />
        ///     objects which happened during <see cref="String" />, <see cref="StringWide"/>, <see cref="CString"/>
        ///     or <see cref="CStringWide" />. Does <b>not</b> garbage collect.
        /// </summary>
        public static void FreeAllStrings()
        {
            foreach (var (ptr, _) in PointersToStrings)
            {
                Marshal.FreeHGlobal(ptr);
            }

            // We can not guarantee that the application has not a strong reference the string since it was allocated,
            //  so we have to let the GC take the wheel here. Thus, this method should NOT garbage collect; that's
            //  on the responsibility of the application developer. The best we can do is just remove any and all strong
            //  references we have here to the strings.

            StringHashesToPointers.Clear();
            PointersToStrings.Clear();
        }

        /// <summary>
        ///     Frees the memory for specific previously allocated C strings and releases associated references to
        ///     <see cref="string" /> objects which happened during <see cref="String" /> or
        ///     <see cref="CString" />. Does <b>not</b> garbage collect.
        /// </summary>
        /// <param name="pointers">The C string pointers.</param>
        /// <param name="count">The number of C string pointers.</param>
        public static void FreeCStrings(CString* pointers, int count)
        {
            for (var i = 0; i < count; i++)
            {
                var ptr = pointers[i];
                FreeCString(ptr);
            }

            Marshal.FreeHGlobal((IntPtr)pointers);
        }

        /// <summary>
        ///     Frees the memory for the previously allocated C string and releases reference to the
        ///     <see cref="string" /> object which happened during <see cref="String" /> or <see cref="CString" />.
        ///     Does <b>not</b> garbage collect.
        /// </summary>
        /// <param name="value">The string.</param>
        public static void FreeCString(CString value)
        {
            if (!PointersToStrings.ContainsKey(value._pointer))
            {
                return;
            }

            Marshal.FreeHGlobal(value);
            var hash = Djb2(value);
            StringHashesToPointers.Remove(hash);
            PointersToStrings.Remove(value._pointer);
        }

        /// <summary>
        ///     Frees the memory for the previously allocated C string and releases reference to the
        ///     <see cref="string" /> object which happened during <see cref="StringWide" /> or <see cref="CStringWide" />.
        ///     Does <b>not</b> garbage collect.
        /// </summary>
        /// <param name="value">The string.</param>
        public static void FreeCStringWide(CStringWide value)
        {
            if (!PointersToStringsWide.ContainsKey(value._pointer))
            {
                return;
            }

            Marshal.FreeHGlobal(value);
            var hash = Djb2(value);
            StringHashesToPointersWide.Remove(hash);
            PointersToStringsWide.Remove(value._pointer);
        }

        // djb2 is named after https://en.wikipedia.org/wiki/Daniel_J._Bernstein
        //  References:
        //  (1) https://stackoverflow.com/a/7666577/2171957
        //  (2) http://www.cse.yorku.ca/~oz/hash.html
        //  (3) https://groups.google.com/g/comp.lang.c/c/lSKWXiuNOAk/m/zstZ3SRhCjgJ
        private static uint Djb2(byte* str)
        {
            // Lucas Girouard-Stranks: my explanation of djb2
            // basic hash algorithm; we want each character in the string to have some bias related to it's position for calculating the hash
            // this is to prevent strings with the same characters but scrambled to not have the same hash values
            // hash = str[0] + g * (str[1] + g * (str[2] + g * (str[3] + g ... * (str[n-2] + g * (str[n-1] + g)))))
            // hash(-1) = x; hash(i) = (hash(i-1) * g) + str[i];
            // note that `i` is an element of the range inclusive from 0 to n-1, where `n` is the length of the string
            // Daniel Bernstein choose `g` to be 33 and hash(-1) to be 5381
            // this coincides with a linear congruential generator for generating pseudo-randomized numbers: https://en.wikipedia.org/wiki/Linear_congruential_generator
            // the basic LCG algorithm is: x(i) = ((a * x(i -1)) + c) + mod m
            // note that integer overflow is equivalent to a modulus operation of the bit width so it's often the case that `m` = 2^32
            // eureka! notice that djb2 then resembles an LCG: x(i) = a * x(i-1) + c
            // for the LCG to generate as random as possible values the value of `a` has some limitations (period length):
            // 1: `m` and `c` are co-prime
            //  this is true when `c` is odd because the only common divisor that could exist between 2^n and `c` is 2
            //  however the fact that condition is not always met is "okay", it still results in a "good enough" LCG
            // 2: `a-1` is divisible by all prime factors of `m`
            //  `a-1` = 32 which is divisible by 2, so of course it's divisible by the only prime factor of 2^n which is 2
            // 3: `a-1` is divisible by 4 if `m` is divisible by 4
            //  this is true, `a-1` being 32 is divisible by 2^2 and so is 2^n where n >= 2
            // note that a good non-cryptographic hash function is NOT intended to generate random numbers
            // instead the intention is that when inputs are nearly identical (one character is different in the string)
            //  that the output is widely different, this is where the first condition NOT being met MIGHT actually be a good thing
            // hopefully someone smarter than me one day will write or talk about the relationship of pseudorandom number
            //  generator (PRNG) and non-cryptographic hash functions for the purposes of data structures like a hashtable

            uint hash = 5381;

            unchecked
            {
                uint c;
                while ((c = *str++) != 0)
                {
                    hash = ((hash << 5) + hash) + c; // hash * 33 + c
                }
            }

            return hash;
        }

        private static uint Djb2(string str)
        {
            uint hash = 5381;

            // ReSharper disable once ForeachCanBeConvertedToQueryUsingAnotherGetEnumerator
            foreach (var c in str)
            {
                hash = (hash << 5) + hash + c; // hash * 33 + c
            }

            return hash;
        }
    }

    /// <summary>
    ///     A pointer value type that represents a wide string; C type `wchar_t*`.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public readonly unsafe struct CStringWide : IEquatable<CStringWide>
    {
        internal readonly nint _pointer;

        /// <summary>
        ///     Gets a value indicating whether this <see cref="CStringWide" /> is a null pointer.
        /// </summary>
        public bool IsNull => _pointer == 0;

        /// <summary>
        ///     Initializes a new instance of the <see cref="CStringWide" /> struct.
        /// </summary>
        /// <param name="value">The pointer value.</param>
        public CStringWide(byte* value)
        {
            _pointer = (nint)value;
        }

        /// <summary>
        ///     Initializes a new instance of the <see cref="CStringWide" /> struct.
        /// </summary>
        /// <param name="value">The pointer value.</param>
        public CStringWide(nint value)
        {
            _pointer = value;
        }

        /// <summary>
        ///     Initializes a new instance of the <see cref="CStringWide" /> struct.
        /// </summary>
        /// <param name="s">The string value.</param>
        public CStringWide(string s)
        {
            _pointer = CStrings.CStringWide(s);
        }

        /// <summary>
        ///     Performs an explicit conversion from a <see cref="IntPtr" /> to a <see cref="CStringWide" />.
        /// </summary>
        /// <param name="value">The pointer value.</param>
        /// <returns>
        ///     The resulting <see cref="CStringWide" />.
        /// </returns>
        public static explicit operator CStringWide(nint value)
        {
            return FromIntPtr(value);
        }

        /// <summary>
        ///     Performs an explicit conversion from a <see cref="IntPtr" /> to a <see cref="CStringWide" />.
        /// </summary>
        /// <param name="value">The pointer value.</param>
        /// <returns>
        ///     The resulting <see cref="CStringWide" />.
        /// </returns>
        public static CStringWide FromIntPtr(nint value)
        {
            return new(value);
        }

        /// <summary>
        ///     Performs an implicit conversion from a byte pointer to a <see cref="CStringWide" />.
        /// </summary>
        /// <param name="value">The pointer value.</param>
        /// <returns>
        ///     The resulting <see cref="CStringWide" />.
        /// </returns>
        public static implicit operator CStringWide(byte* value)
        {
            return From(value);
        }

        /// <summary>
        ///     Performs an implicit conversion from a byte pointer to a <see cref="CStringWide" />.
        /// </summary>
        /// <param name="value">The pointer value.</param>
        /// <returns>
        ///     The resulting <see cref="CStringWide" />.
        /// </returns>
        public static CStringWide From(byte* value)
        {
            return new((nint)value);
        }

        /// <summary>
        ///     Performs an implicit conversion from a <see cref="CStringWide" /> to a <see cref="IntPtr" />.
        /// </summary>
        /// <param name="value">The pointer.</param>
        /// <returns>
        ///     The resulting <see cref="IntPtr" />.
        /// </returns>
        public static implicit operator nint(CStringWide value)
        {
            return value._pointer;
        }

        /// <summary>
        ///     Performs an implicit conversion from a <see cref="CStringWide" /> to a <see cref="IntPtr" />.
        /// </summary>
        /// <param name="value">The pointer.</param>
        /// <returns>
        ///     The resulting <see cref="IntPtr" />.
        /// </returns>
        public static nint ToIntPtr(CStringWide value)
        {
            return value._pointer;
        }

        /// <summary>
        ///     Performs an implicit conversion from a <see cref="CStringWide" /> to a <see cref="string" />.
        /// </summary>
        /// <param name="value">The <see cref="CStringWide" />.</param>
        /// <returns>
        ///     The resulting <see cref="string" />.
        /// </returns>
        public static implicit operator string(CStringWide value)
        {
            return ToString(value);
        }

        /// <summary>
        ///     Performs an implicit conversion from a <see cref="CStringWide" /> to a <see cref="string" />.
        /// </summary>
        /// <param name="value">The <see cref="CStringWide" />.</param>
        /// <returns>
        ///     The resulting <see cref="string" />.
        /// </returns>
        public static string ToString(CStringWide value)
        {
            return CStrings.StringWide(value);
        }

        /// <summary>
        ///     Performs an implicit conversion from a <see cref="string" /> to a <see cref="CStringWide" />.
        /// </summary>
        /// <param name="s">The <see cref="string" />.</param>
        /// <returns>
        ///     The resulting <see cref="CStringWide" />.
        /// </returns>
        public static implicit operator CStringWide(string s)
        {
            return FromString(s);
        }

        /// <summary>
        ///     Performs an implicit conversion from a <see cref="string" /> to a <see cref="CStringWide" />.
        /// </summary>
        /// <param name="s">The <see cref="string" />.</param>
        /// <returns>
        ///     The resulting <see cref="CStringWide" />.
        /// </returns>
        public static CStringWide FromString(string s)
        {
            return CStrings.CStringWide(s);
        }

        /// <inheritdoc />
        public override string ToString()
        {
            return CStrings.StringWide(this);
        }

        /// <inheritdoc />
        public override bool Equals(object? obj)
        {
            return obj is CStringWide value && Equals(value);
        }

        /// <inheritdoc />
        public bool Equals(CStringWide other)
        {
            return _pointer == other._pointer;
        }

        /// <inheritdoc />
        public override int GetHashCode()
        {
            return _pointer.GetHashCode();
        }

        /// <summary>
        ///     Returns a value that indicates whether two specified <see cref="CStringWide" /> structures are equal.
        /// </summary>
        /// <param name="left">The first <see cref="CStringWide" /> to compare.</param>
        /// <param name="right">The second <see cref="CStringWide" /> to compare.</param>
        /// <returns><c>true</c> if <paramref name="left"/> and <paramref name="right"/> are equal; otherwise, <c>false</c>.</returns>
        public static bool operator ==(CStringWide left, CStringWide right)
        {
            return left._pointer == right._pointer;
        }

        /// <summary>
        ///     Returns a value that indicates whether two specified <see cref="CBool" /> structures are not equal.
        /// </summary>
        /// <param name="left">The first <see cref="CStringWide" /> to compare.</param>
        /// <param name="right">The second <see cref="CStringWide" /> to compare.</param>
        /// <returns><c>true</c> if <paramref name="left"/> and <paramref name="right"/> are not equal; otherwise, <c>false</c>.</returns>
        public static bool operator !=(CStringWide left, CStringWide right)
        {
            return !(left == right);
        }

        /// <summary>
        ///     Returns a value that indicates whether two specified <see cref="CStringWide" /> structures are equal.
        /// </summary>
        /// <param name="left">The first <see cref="CStringWide" /> to compare.</param>
        /// <param name="right">The second <see cref="CStringWide" /> to compare.</param>
        /// <returns><c>true</c> if <paramref name="left"/> and <paramref name="right"/> are equal; otherwise, <c>false</c>.</returns>
        public static bool Equals(CStringWide left, CStringWide right)
        {
            return left._pointer == right._pointer;
        }
    }
}